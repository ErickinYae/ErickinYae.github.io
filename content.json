{"meta":{"title":"Erickin","subtitle":"","description":"","author":"Erickin","url":"https://erickinyae.github.io","root":"/"},"pages":[{"title":"about","date":"2023-10-20T02:13:30.000Z","updated":"2023-11-05T14:40:20.000Z","comments":true,"path":"about/index.html","permalink":"https://erickinyae.github.io/about/index.html","excerpt":"","text":"努力学习 快乐生活！测试。"},{"title":"书单","date":"2023-11-09T05:17:20.605Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"books/index.html","permalink":"https://erickinyae.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-09T05:17:20.606Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"categories/index.html","permalink":"https://erickinyae.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-09T05:17:20.607Z","updated":"2023-11-06T06:52:30.000Z","comments":true,"path":"links/index.html","permalink":"https://erickinyae.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-09T05:17:20.610Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"tags/index.html","permalink":"https://erickinyae.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-09T05:17:20.608Z","updated":"2023-11-06T06:52:30.000Z","comments":false,"path":"repository/index.html","permalink":"https://erickinyae.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"安全基础","slug":"安全基础","date":"2023-11-09T05:33:04.000Z","updated":"2023-11-09T05:47:26.982Z","comments":true,"path":"2023/11/09/安全基础/","permalink":"https://erickinyae.github.io/2023/11/09/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"资源 地址 描述 https://tryhackme.com/dashboard# 攻击与网络基础 https://tryhackme.com/room/owasptop102021 OWASP TOP10 https://labs.play-with-docker.com/ docker学习 https://cyberdefenders.org/blueteam-ctf-challenges/ 蓝队训练 资讯 地址 描述 https://sec.today/pulses/ 每日安全","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://erickinyae.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"代码审计学习流程","slug":"代码审计LP","date":"2023-11-09T02:44:56.000Z","updated":"2023-11-09T03:39:44.000Z","comments":true,"path":"2023/11/09/代码审计LP/","permalink":"https://erickinyae.github.io/2023/11/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1LP/","excerpt":"","text":"资源审计入门： https://github.com/JoyChou93/java-sec-code 博客： https://skewwg.github.io/ 进阶： 在github中搜java cms项目，拉下来进行代码审计。","categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"审计","slug":"审计","permalink":"https://erickinyae.github.io/tags/%E5%AE%A1%E8%AE%A1/"}]},{"title":"mysql","slug":"mysql","date":"2023-11-06T02:34:30.000Z","updated":"2023-11-09T07:54:03.587Z","comments":true,"path":"2023/11/06/mysql/","permalink":"https://erickinyae.github.io/2023/11/06/mysql/","excerpt":"","text":"基础概念关系型数据库设计规则 关系型数据库的典型数据结构是数据表； 数据在表中，表在库中； 一个数据库可以有多个表，表名是唯一不重复的； 表具有一些属性，定义了数据在表中如何存储； DB、DBMS、SQL的关系 DB：database是一个数据库文件，类似.doc，.txt等； DBMS：数据库管理系统，类似(word、wps工具)； MySQL数据库服务器中安装了MySQL DBMS，使用MySQL DBMS来管理和操作DB，使用的是SQL语言。 自带数据库 information_schema：保存数据库中存在的库、表等信息； mysql：保存相关的配置信息； performance_schema：保存数据库的运行状态信息； sys：系统相关信息； SQL语句分类 DDL：数据定义语言：CREATE\\ALTER\\DROP\\RENAME\\TRUNCATE DML：数据操作语言：INSERT\\DELETE\\UPDATE\\SELECT DCL：数据控制语言：COMMIT\\ROLLBACK\\SAVEPOINT\\GRANT\\REVOKE 语句规范 SQL可以写在一行或多行，为了提高可读性，各句子分开写，必要时使用缩进； 每一条命令以 ;或\\g或\\G 结束； 关键字不能被缩写、也不能被分行； 标点符号方面： 所有 ()、单引号、双引号必须成对结束； 必须使用英文半角输入； 字符串类型和日期时间类型的数据可以使用单引号 &#39;&#39;表示； 列的别名，尽量使用双引号 &quot;&quot;，且不要省略as； 大小写： MySQL在Windows环境下大小写不敏感，在Linux环境下大小写敏感； 数据库名、表名、表别名、变量名严格区分大小写； 关键字、函数名、列名（字段名）、列别名（字段别名）忽略大小写； 推荐的书写规范： 数据库名、表名、表别名、字段名、字段别名都小写； SQL关键字、函数名、绑定变量都大写； 注释 单行注释 #注释文字 单行注释 -- 注释文字 多行注释 /* 注释文字 */ 命名规则 数据库、表名不超过30个字符，变量名限制为29个； 必须只能包含A-Z，a-z，0-9, _共63个字符； 数据库名、表名、字段名等对象名中间不能包含空格； 同一个MySQL软件中，数据库不能同名；同一个库中，表不能同名；同一个表中，字段不能同名； 必须保证字段和保留字、数据库系统或常用方法名不发生冲突，如果必须使用，则必须使用 &#39;&#39;引起来； 保证字段名和类型的一致性，在命名字段并为其制定数据类型的时一定要保证一致性。假如数据类型在一个表中是整数，在另一个表中则不要为字符型； 基本数据类型 种类 类型 整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT 浮点类型 FLOAT、DOUBLE 定点数类型 DECIMAL 位类型 BIT 日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型 ENUM 集合类型 SET 二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型 JSON对象、JSON数组 空间数据类型 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 常用数据类型 数据类型 描述 INT 从-2^31到2^31-1的整型数据。存储大小为 CHAR(size) 定长字符数据。若未指定，默认为1个字符，最大长度255 VARCHAR(size) 可变长字符数据，根据字符串实际长度保存，必须指定长度 FLOAT(M,D) 单精度，占用4个字节，M&#x3D;整数位+小数位，D&#x3D;小数位。 DOUBLE(M,D) 双精度，占用8个字节，D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;15 DECIMAL(M,D) 高精度小数，占用M+2个字节，D&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，最大取值范围与DOUBLE相同 DATE 日期型数据，格式’YYYY-MM-DD’ BLOB 二进制形式的长文本数据，最大可达4G TEXT 长文本数据，最大可达4G 库表操作DESC 表名：查看表所有的字段 字段 描述 Field 字段名称 Type 字段类型 Null 表示该属性是否可以存储null值 Key 表示该列是否有索引，如果是PRI则表示该列是表的主键，UNI表示是UNIQUE索引的一部分，MUL表示在列中某个指定值允许出现多次 Default 表示该列是否有默认值，如果有在这里将显示值 Extra 表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等（自增） 数据库创建数据库 代码 描述 CREATE DATABASE 数据库名; 创建数据库 CREATE DATABASE 数据库名 CHARACTER SET 字符集; 创建数据库并指定字符集 CREATE DATABASE IF NOT EXISTS 数据库名; 判断数据库是否已经存在，不存在则创建数据库（ 推荐 ） 使用数据库 代码 描述 SHOW DATABASES; #有一个S，代表多个数据库; 查看当前所有的数据库 SELECT DATABASE(); 查看当前正在使用的数据库 SHOW TABLES FROM 数据库名; 查看指定库下所有的表 SHOW CREATE DATABASE 数据库名;SHOW CREATE DATABASE 数据库名\\G; 查看数据库的创建信息 USE 数据库名; 使用&#x2F;切换数据库 修改数据库 代码 描述 ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等; 更改数据库字符集 DROP DATABASE 数据库名; 删除指定的数据库 DROP DATABASE IF EXISTS 数据库名; 删除指定的数据库 表创建表创建方法11234567CREATE TABLE [IF NOT EXISTS] 表名(字段1, 数据类型 [约束条件] [默认值],字段2, 数据类型 [约束条件] [默认值],字段3, 数据类型 [约束条件] [默认值],……[表约束条件]); Eg: 1234567891011121314151617181920#Eg1:CREATE TABLE emp (-- int类型emp_id INT,-- 最多保存20个中英文字符emp_name VARCHAR(20),-- 总位数不超过15位salary DOUBLE,-- 日期类型birthday DATE);#Eg2:CREATE TABLE dept(-- int类型，自增deptno INT(2) AUTO_INCREMENT,dname VARCHAR(14),loc VARCHAR(13),-- 主键PRIMARY KEY (deptno)); 创建方法212CREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表 Eg: 12345CREATE TABLE dept80ASSELECT employee_id, last_name, salary*12 ANNSAL, hire_dateFROM employeesWHERE department_id = 80; 查看表 代码 描述 DESC 表名 表结构 SHOW CREATE TABLE 表名 表结构查询 修改表追加列 指令 描述 ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST/AFTER 字段名】; Eg: 12ALTER TABLE dept80ADD job_id varchar(15); 修改列 指令 描述 ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST/AFTER 字段名】; 可以修改列的数据类型，长度、默认值和位置 Eg: 1234ALTER TABLE dept80MODIFY last_name VARCHAR(30);ALTER TABLE dept80MODIFY salary double(9,2) default 1000; 重命名列 指令 描述 ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; Eg: 12ALTER TABLE dept80CHANGE department_name dept_name varchar(15); 删除列 指令 描述 ALTER TABLE 表名 DROP 【COLUMN】字段名 重命名表 指令 描述 RENAME TABLE emp TO myemp; rename ALTER table dept RENAME [TO] detail_dept; alter 删除表 指令 描述 DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n]; 当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除； 清空表 指令 描述 TRUNCATE TABLE detail_dept； 删除表中所有的数据表，释放表的存储空间； TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚； 改 指令 描述 alter table 表名 modify 字段 字段类型 修改字段类型 alter table 表名 add 字段 字段类型 添加新的字段 alter table 表名 add 字段 字段类型 after 字段 添加字段并指定位置 alter table 表名 drop 字段名 删除表字段 alter table 表名 change 原字段名字 新的字段名字 字段类型 修改指定的字段 ALTER DATABASE 数据库名 CHARACTER SET 字符集 修改数据库字符集-&gt; gbk、utf-8 数据操作SELECT 名称 语法 说明 举例 基本语法 SELECT ... FROM ... 属性别名 SELECT ... AS ... FROM ... SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot; FROM employees; 去除重复行 SELECT DISTINCT ... FROM ... 注意，如果DISTINCT后面跟了多个属性，则是根据多个属性的匹配情况进行去重，比如有两个属性id, salary，则id和salary的值都一样，才会去重处理。 SELECT DISTINCT department_id FROM employees; 空值运算 - 所有运算符或列值遇到null值，运算结果都为null（如1+null &#x3D; null） 常数查询 - select可以使用常数查询，来对数据进行分割等行为 SELECT &#39;***&#39; AS corporation, last_name FROM employees; WHERE后的语法 类别 语法 说明 关系 &gt;, &lt;, &gt;=, &lt;=, !=, = 逻辑 OR, AND 区间 id BETWEEN 4 and 6 区间为闭区间，包含左右边界 排序 语法 说明 举例 &#96;SELECT 字段 FROM 表 ORDER BY 字段 排序关键词(DESC ASC)&#96; DESC：降序；ASC：升序； &#96;SELECT 字段 FROM 表 ORDER BY 字段1 DESC ASC, … 字段N DESC ASC&#96; 聚合 语法 说明 举例 sum() 求和 avg() 求平均数 count() 统计数量 select count(sex) from star group by sex max() 求最大值 min() 求最小值 group by 字段 按字段分组 select count(sex) as re,sex from star group by sex having re &gt; 3 select * from 表名 limit 偏移量,数量 偏移量，如果不写偏移量的话默认是0；实现分页查询的时候必须写偏移量； 多表联合查询 类型 说明 描述 语法 内连接 隐式内连接 select username,name from user,goods where user.gid=gods.gid 内连接 显式内连接 select username,from user inner join goods on user.gid=goods.gidselect * from user left join goods on user.gid=goods.gid 外连接 左连接 包含所有的左边表中的记录以及右边表中没有和他匹配的记录 外连接 右连接 select * from user right jOin goods on user.gid=goods.gid 子嵌套查询 select * from user where gid in(select gid from goods) 数据联合查询 将两次查询的结果联合到一起 select * from user left join goods on user.gid=goods.gid union select * from user right join goods on user.gid=goods.gid 两个表同时更新 update user u, goods g set u.gid=12,g.price=1 where u.id=2 and u.gid=g.gid 运算符算术运算符 运算符 名称 作用 示例 + 加法 计算两个值或表达式的和 SELECT A+B - 减法 计算两个值或表达式的差 SELECT A-B * 乘法 计算两个值或表达式的乘积 SELECT A*B &#x2F;或DIV 除法 计算两个值或者表达式的商 SELECT A&#x2F;B or SELECT A DIV B %或MOD 求模（求余） 计算两个值的余数 SELECT A%B or SELECT A MOD B 加减 整数与浮点数进行加法和减法，结果是一个浮点数； 在MySQL中+只表示数值相加，如果遇到非数值类型，先尝试转成数值，如果转失败，则按0计算； MySQL字符串拼接使用字符串函数CONCAT()实现。 乘除 一个整数乘除一个浮点数1都变成浮点数，数值与原数相等； 一个数除以整数后，无论是否除尽，结果都为一个浮点数； 一个数除以另一个数，除不尽时，结果为一个浮点数，且保留到小数点后四位； MySQL中一个数除以0为NULL； 比较运算符 运算符 名称 &#x3D; 等于 &lt;&#x3D;&gt; 安全等于 &lt;&gt;(!&#x3D;) 不等于 &lt; 小于 &lt;&#x3D; 小于等于 &gt; 大于 &gt;&#x3D; 大于等于 字符串和字符串比较，比较的是内容； 整数和整数比较，比较的是值； 整数和字符串比较，将会将字符串转换为数字进行比较； 等号两边如果有一个NULL，则比较结果为NULL； 非符号运算符 运算符 名称 描述 举例 IS NOT NULL 不为空运算符 判断值、字符串或表达式是否不为空 SELECT B FROM TABLE WHERE A IS NOT NULL LEAST 最小值运算符 在多个值中返回最小值 SELECT D FROM TABLE WHERE C LEAST(A, B) GREATEST 最大值运算符 在多个值中返回最大值 SELECT D FROM TABLE WHERE C GREATEST(A, B) BETWEEN * AND * 两个值之间的运算符 判断一个值是否在两个值之间 SELECT D FROM TABLE WHERE C BETWEEN A AND B IS NULL 为空运算符 判断一个值、字符串或表达式是否为空 SELECT B FROM TABLE WHERE A IS NULL IN 属于运算符 判断一个值是否在列表中 SELECT D FROM TABLE WHERE C IN (A, B) NOT IN 不属于运算符 判断一个值是否不在列表中 SELECT D FROM TABLE WHERE C NOT IN (A, B) LIKE 模糊匹配运算符 判断一个值是否符合模糊匹配规则 SELECT C FROM TABLE WHERE A LIKE B REGEXP 正则表达式运算符 判断一个值是否符合正则表达式规则 SELECT C FROM TABLE WHERE A REGEXP B RLIKE 正则表达式运算符 判断一个值是否符合正则表达式规则 SELECT C FROM TABLE WHERE A RLIKE B LIKE模糊匹配运算符： %：匹配0个或多个字符； _：只能匹配一个字符； 运算符优先级数值越高，优先级越高。 优先级 运算符 1 &#x3D;（赋值） 2 ||、OR、XOR 3 &amp;&amp;，AND 4 NOT 5 BETWEEN、CASE、WHEN、THEN和ELSE 6 &#x3D;、&lt;&#x3D;&gt;、&gt;&#x3D;、&gt;、&lt;&#x3D;、&lt;、&lt;&gt;、!&#x3D;、 IS、LIKE、REGEXP和IN 7 | 8 &amp; 9 &lt;&lt;和&gt;&gt; 10 -和+ 11 *、&#x2F;、DIV、%和MOD 12 ^ 13 -(负号)和~(按位取反) 14 ! 15 () 分页查询格式： 1Limit [位置偏移量, ] 行数 Eg： 1234567#前10条记录:SELECT * FROM table_name LIMIT 0, 10;SELECT * FROM table_name LIMIT 10;#第11至20条记录:SELECT * FROM table_name LIMIT 10,10;#第21至30条记录:SELECT * FROM table_name LIMIT 20,10; 分页显式公式： 1SELECT * FROM table_name LIMIT(PageNo - 1)*PageSize, PageSize; 多表查询自连接将同一个表分别取两个别名赋予不同的含义（类比快捷方式），然后再将两个表进行内连接、外连接等查询； 1234SELECT CONCAT(worker.last_name ,&#x27; works for &#x27;, manager.last_name)FROM employees worker, employees managerWHERE worker.manager_id = manager.employee_id 内连接与外连接 内连接：合并具有同一列的两个以上的表行，结果集中不包含一个表和另一个表不匹配的行； 外连接：除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行，称为左连接或右连接，没有匹配的行时，表中相应的列为NULL； 如果左外连接，左表为主表，右表为从表； 如果右外连接，右表为主表，左表为从表； JOIN…ON1234SELECT table1.column, table2.column,table3.columnFROM table1JOIN table2 ON table1 和 table2 的连接条件JOIN table3 ON table2 和 table3 的连接条件 INNER JOIN通常写的JOIN就是INNER JOIN，将INNER省略掉了而已，即INNER JOIN ≈ JOIN； 1234SELECT 字段列表FROM A表 INNER JOIN B表ON 关联条件WHERE 等其他子句; OUTER JOINLEFT OUTER JOIN1234SELECT 字段列表FROM A表 LEFT JOIN B表ON 关联条件WHERE 等其他子句; Eg: 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id = d.department_id) ; RIGHT OUTER JOIN123FROM A表 RIGHT JOIN B表ON 关联条件WHERE 等其他子句; Eg: 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id = d.department_id) ; UNION 合并查询结果，利用UNION 关键词可以给出多条SELECT语句，并将它们的结果组合成单个结果集； 合并时两个查询结果的列数和数据类型必须相同，并以“串联”形式进行组合。 123SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2 Eg: 123456#方式一：SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;#方式二：SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27;UNIONSELECT * FROM employees WHERE department_id&gt;90; UNION和UNION ALL UNION操作符会将两个查询的结果集并集时去除重复记录； UNION ALL操作符返回两个查询的结果集的并集但并不去除重复部分。 NATURAL JOIN它会帮你自动查询两张连接表中所有相同的字段 ，然后进行等值连接 。 12345678#原语句SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`AND e.`manager_id` = d.`manager_id`#利用NUTURAL JOIN改写为SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d; USING当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配合JOIN一起使用。比如： 123SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id); 你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING的括号 () 中填入要指定的同名字段。同时使用 JOIN…USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的 123SELECT employee_id,last_name,department_nameFROM employees e ,departments dWHERE e.department_id = d.department_id 子查询 子查询（内查询）在主查询之前一次执行完成； 子查询的结果被主查询（外查询）使用 ； 子查询要包含在括号内； 将子查询放在比较条件的右侧； 单行操作符对应单行子查询，多行操作符对应多行子查询； 单行子查询比较操作符 语法 说明 &#x3D; equal to &gt; greater than &gt;&#x3D; greater than or equal to &lt; less than &lt;&#x3D; less than or equal to &lt;&gt; not equal to 多行子查询比较操作符 语法 说明 IN 等于列表中的任意一个 ANY 需要和单行比较操作符一起使用，和子查询返回的某一个值比较 ALL 需要和单行比较操作符一起使用，和子查询返回的所有值比较 SOME 实际上是ANY的别名，作用相同，一般常使用ANY 计算列 mysql8.0新特性 123456CREATE TABLE tb1(id INT,a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL); INSERT 语法 说明 insert into 表名 values(值1，值2，…) 很少用 insert into 表名(字段1，字段2…) values(值1，值2，….) 常用 insert into 表名(字段1，字段2…) values(值1，值2，….)，(值1，值2，….)，(值1，值2，….) DELETE 语法 说明 delete from 表名 where 条件 where 条件必须加，否则数据会被全部删除 UPDATE 语法 说明 update 表名 set 字段1 &#x3D; 值1, 字段2 &#x3D; 值2 where 条件 DCL权限控制 描述 指令 说明 创建用户 CREATE USER &#39;用户名&#39;@&#39;客户端地址&#39; IDENTIFIED BY &#39;密码&#39; 授权用户 GRANT 权限 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39; 上述命令中，权限可以是SELECT、INSERT、UPDATE、DELETE等操作，也可以是ALL表示所有操作。数据库名和表名可以使用通配符*表示所有，用户名和主机名也可以使用通配符%表示所有。IDENTIFIED BY后面紧跟的是密码。 刷新权限 flush privileges 取消授权 revoke all on test.* from &#39;xiaoming&#39;@&#39;localhost&#39; 上述命令中，权限可以是SELECT、INSERT、UPDATE、DELETE等操作，也可以是ALL表示所有操作。数据库名和表名可以使用通配符*表示所有，用户名和主机名也可以使用通配符%表示所有。IDENTIFIED BY后面紧跟的是密码。 删除用户 drop user&#39;xiaoming&#39;@&#39;localhost&#39; 查看用户权限 SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; 函数聚合函数基本聚合函数 函数 说明 AVG() 平均 SUM() 总数 MIN() 最小 MAX() 最大 COUNT(*) 表的行数 COUNT(expr) 返回expr不为空的记录总数 MyISAM和InnoDB的在对行数统计上的区别： MyISAM有个整型计数器在记录行数，通过 count(*)、count(1)、count(列名)都是从该整型值位置获取值； InnoDB不存在行数计数器，因此每次执行count(*)、count(1)、count(列名)都会完整计数一遍行数。 count(列名)和 count(*)可以互换吗： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 GROUP BY12345SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column]; Eg: 12345678#单列分组SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id;#多列分组SELECT department_id dept_id, job_id, SUM(salary)FROM employeesGROUP BY department_id, job_id; WITH ROLLUP 该关键字可以让所有查询出的分组记录之后增加一个记录，该记录可计算查询出的所有记录总和。 1234SELECT department_id,AVG(salary)FROM employeesWHERE department_id &gt; 80 #不能在WHERE子句中使用集合函数。GROUP BY department_id WITH ROLLUP; ROLLUP和ORDER BY不可以同时使用，相互排斥。 HAVING 将使用GROUP BY聚合的结果再进行过滤筛选。 行已经被分组; 使用了聚合函数; 满足HAVING 子句中条件的分组将被显示; HAVING 不能单独使用，必须要跟 GROUP BY 一起使用； 不能在WHERE子句中使用聚合函数(GROUP BY)。 WHERE和HAVING的对比： WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件； 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选； 如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选；这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 总结： 语法 优点 缺点 WHERE 先筛选数据再关联，执行效率高 不能使用分组中的计算函数进行筛选 HAVING 可以使用分组中的计算函数 在最后的结果集中进行筛选，执行效率低 数值函数基本函数 指令 说明 ABS(x) 返回x的绝对值 SIGN(X) 返回X的符号。正数返回1，负数返回-1，0返回0 PI() 返回圆周率的值 CEIL(x)，CEILING(x) 返回大于或等于某个值的最小整数 FLOOR(x) 返回小于或等于某个值的最大整数 LEAST(e1,e2,e3…) 返回列表中的最小值 GREATEST(e1,e2,e3…) 返回列表中的最大值 MOD(x,y) 返回X除以Y后的余数 RAND() 返回0~1的随机值 RAND(x) 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 ROUND(x) 返回一个对x的值进行四舍五入后，最接近于X的整数 ROUND(x,y) 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 TRUNCATE(x,y) 返回数字x截断为y位小数的结果 SQRT(x) 返回x的平方根。当X的值为负数时，返回NULL 角度函数 指令 说明 RADIANS(x) 将角度转化为弧度，其中，参数x为角度值 DEGREES(x) 将弧度转化为角度，其中，参数x为弧度值 三角函数 指令 说明 SIN(x) 返回x的正弦值，其中，参数x为弧度值 ASIN(x) 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL COS(x) 返回x的余弦值，其中，参数x为弧度值 ACOS(x) 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL TAN(x) 返回x的正切值，其中，参数x为弧度值 ATAN(x) 返回x的反正切值，即返回正切值为x的值 ATAN2(m,n) 返回两个参数的反正切值 COT(x) 返回x的余切值，其中，X为弧度值 次方与对数函数 指令 说明 POW(x,y)，POWER(X,Y) 返回x的y次方 EXP(X) 返回e的X次方，其中e是一个常数，2.718281828459045 LN(X)，LOG(X) 返回以e为底的X的对数，当X LOG10(X) 返回以10为底的X的对数，当X LOG2(X) 返回以2为底的X的对数，当X 进制转换函数 指令 说明 BIN(x) 返回x的二进制编码 HEX(x) 返回x的十六进制编码 OCT(x) 返回x的八进制编码 CONV(x,f1,f2) 返回f1进制数变成f2进制数 字符串函数 MySQL中，字符串的位置从1开始。 指令 说明 ASCII(S) 返回字符串S中的第一个字符的ASCII码值 CHAR_LENGTH(s) 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同 LENGTH(s) 返回字符串s的字节数，和字符集有关 CONCAT(s1,s2,……,sn) 连接s1,s2,……,sn为一个字符串 CONCAT_WS(x,s1,s2,……,sn) 同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x INSERT(str,idx,len,replacestr) 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr REPLACE(str,a,b) 用字符串b替换字符串str中所有出现的字符串a UPPER(s)或UCASE(s) 将字符串s的所有字母转成大写字母 LOWER(s)或LCASE(s) 将字符串s的所有字母转成小写字母 LEFT(str,n) 返回字符串str最左边的n个字符 RIGHT(str,n) 返回字符串str最右边的n个字符 LPAD(str,len,pad) 用字符串pad对str最左边进行填充，直到str的长度为len个字符 RPAD(str,len,pad) 用字符串pad对str最右边进行填充，直到str的长度为len个字符 LTRIM(s) 去掉字符串s左侧的空格 RTRIM(s) 去掉字符串s右侧的空格 TRIM(s) 去掉字符串s开始与结尾的空格 TRIM(s1 FROM s) 去掉字符串s开始与结尾的s1 TRIM(LEADING s1 FROM s) 去掉字符串s开始处的s1 TRIM(TRAILING s1 FROM s) 去掉字符串s结尾处的s1 REPEAT(str, n) 返回str重复n次的结果 SPACE(n) 返回n个空格 STRCMP(s1,s2) 比较字符串s1,s2的ASCII码值的大小 SUBSTR(s,index,len) 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同 LOCATE(substr,str) 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr ELT(m,s1,s2,…,sn) 返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn FIELD(s,s1,s2,…,sn) 返回字符串s在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2) 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 REVERSE(s) 返回s反转后的字符串 NULLIF(value1,value2) 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1 日期时间函数 指令 说明 CURDATE()，CURRENT_DATE() 返回当前日期，只包含年、月、日 CURTIME()，CURRENT_TIME() 返回当前时间，只包含时、分、秒 NOW()&#x2F;SYSDATE()&#x2F;CURRENT_TIMESTAMP()&#x2F;LOCALTIME()&#x2F;LOCALTIMESTAMP() 返回当前系统日期和时间 UTC_DATE() 返回UTC（世界标准时间）日期UTC_TIME()返回UTC（世界标准时间）时间 UNIX_TIMESTAMP() 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP()-&gt;1634348884 UNIX_TIMESTAMP(date) 将时间date以UNIX时间戳的形式返回 FROM_UNIXTIME(timestamp) 将UNIX时间戳的时间转换为普通格式的时间 YEAR(date)&#x2F;MONTH(date)&#x2F;DAY(date) 返回具体的日期值 HOUR(time)&#x2F;MINUTE(time)&#x2F;SECOND(time) 返回具体的时间值 MONTHNAME(date) 返回月份：January，… DAYNAME(date) 返回星期几：MONDAY，TUESDAY…..SUNDAY WEEKDAY(date) 返回周几，注意，周1是0，周2是1，。。。周日是6 QUARTER(date) 返回日期对应的季度，范围为1～4 WEEK(date)，WEEKOFYEAR(date) 返回一年中的第几周 DAYOFYEAR(date) 返回日期是一年中的第几天 DAYOFMONTH(date) 返回日期位于所在月份的第几天 DAYOFWEEK(date) 返回周几，注意：周日是1，周一是2，。。。周六是7 TIME_TO_SEC(time) 将time转化为秒并返回结果值。转化的公式为：小时3600+分钟60+秒 SEC_TO_TIME(seconds) 将seconds描述转化为包含小时、分钟和秒的时间 DATE_ADD(datetime,INTERVAL_exprtype)，ADDDATE(date,INTERVALexprtype) 返回与给定日期时间相差INTERVAL时间段的日期时间 DATE_SUB(date,INTERVALexprtype)，SUBDATE(date,INTERVALexprtype) 返回与date相差INTERVAL时间间隔的日期 ADDTIME(time1,time2) 返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数 SUBTIME(time1,time2) 返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数 DATEDIFF(date1,date2) 返回date1-date2的日期间隔天数 TIMEDIFF(time1,time2) 返回time1-time2的时间间隔 FROM_DAYS(N) 返回从0000年1月1日起，N天以后的日期 TO_DAYS(date) 返回日期date距离0000年1月1日的天数 LAST_DAY(date) 返回date所在月份的最后一天的日期 MAKEDATE(year,n) 针对给定年份与所在年份中的天数返回一个日期 MAKETIME(hour,minute,second) 将给定的小时、分钟和秒组合成时间并返回 PERIOD_ADD(time,n) 返回time加上n后的时间 DATE_FORMAT(date,fmt) 按照字符串fmt格式化日期date值 TIME_FORMAT(time,fmt) 按照字符串fmt格式化时间time值 GET_FORMAT(date_type,format_type) 返回日期字符串的显示格式 STR_TO_DATE(str,fmt) 按照字符串fmt对str进行解析，解析为一个日期 流程控制函数 函数 用法 IF(value,value1,value2) 如果value的值为TRUE，返回value1，否则返回value2 IFNULL(value1,value2) 如果value1不为NULL，返回value1，否则返回value2 CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 ….[ELSE 值n] END 相当于Java的if…elseif…else… CASE expr WHEN 常量值1 THEN值1 WHEN 常量值1 THEN值1 …. [ELSE 值n] END 相当于Java的switch…case… 12345SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;ELSE &#x27;草根&#x27; END &quot;描述&quot;FROM employees; 12SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))FROM employees; 123456SELECT last_name, job_id, salary,CASE job_id WHEN &#x27;IT_PROG&#x27; THEN 1.10*salaryWHEN &#x27;ST_CLERK&#x27; THEN 1.15*salaryWHEN &#x27;SA_REP&#x27; THEN 1.20*salaryELSE salary END &quot;REVISED_SALARY&quot;FROM employees 加密解密函数 函数 用法 PASSWORD(str) 返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密 MD5(str) 返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL SHA(str) 从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。 ENCODE(value,password_seed) 返回使用password_seed作为加密密码加密value DECODE(value,password_seed) 返回使用password_seed作为加密密码解密value MySQL信息函数 函数 用法 VERSION() 返回当前MySQL的版本号 CONNECTION_ID() 返回当前MySQL服务器的连接数 DATABASE()，SCHEMA() 返回MySQL命令行当前所在的数据库 USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER() 返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名” CHARSET(value) 返回字符串value自变量的字符集 COLLATION(value) 返回字符串value的比较规则 其他函数 函数 用法 FORMAT(value,n) 返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位 CONV(value,from,to) 将value的值进行不同进制之间的转换 INET_ATON(ipvalue) 将以点分隔的IP地址转化为一个数字 INET_NTOA(value) 将数字形式的IP地址转化为以点分隔的IP地址 BENCHMARK(n,expr) 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间 CONVERT(value USING char_code) 将value所使用的字符编码修改为char_code SELECT执行过程查询结构1234567891011121314151617181920212223242526272829#方式1：SELECT ...,....,...FROM ...,...,....WHERE 多表的连接条件AND 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#方式2：SELECT ...,....,...FROM ... JOIN ...ON 多表的连接条件JOIN ...ON ...WHERE 不包含组函数的过滤条件AND/OR 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#其中：#（1）from：从哪些表中筛选#（2）on：关联多表查询时，去除笛卡尔积#（3）where：从表中筛选的条件#（4）group by：分组依据#（5）having：在统计结果中再次筛选#（6）order by：排序#（7）limit：分页 执行顺序关键词顺序： 1SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT... 语句实际执行顺序： 1FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT 约束 约束 描述 NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束 FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 查看某个表已有的约束 1234#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraintsWHERE table_name = &#x27;表名称&#x27;; 非空约束 NOT NULL1NOT NULL 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型； 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空； 一个表可以有很多列都分别限定了非空； 空字符串’’不等于NULL，0也不等于NULL； 123456789101112#创建时CREATE TABLE 表名称(字段名 数据类型,字段名 数据类型 NOT NULL,字段名 数据类型 NOT NULL);#建表后alter table 表名称 modify 字段名 数据类型 not null;#删除非空约束alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空或alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空 唯一约束 UNIQUE1UNIQUE 同一个表可以有多个唯一约束。 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引。 1234567891011121314151617181920alter table 表名称 add unique key(字段列表);或#创建时create table 表名称(字段名 数据类型,字段名 数据类型 unique,字段名 数据类型 unique key,字段名 数据类型);create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,[constraint 约束名] unique key(字段名));#建表后alter table 表名称 add unique key(字段列表);或alter table 表名称 modify 字段名 字段类型 unique;#删除约束 复合唯一约束1234567create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的); 删除唯一约束 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。 12ALTER TABLE USERDROP INDEX uk_name_pwd； 查看约束 1SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束 查看索引 1show index from 表名称; 主键约束 PRIMARY KEYprimary key，用来唯一标识表中的一行记录。 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值； 一个表中最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别创建； 主键约束对应表中的一列或多列（复合主键）； 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复； MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用； 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了； 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。 添加主键约束建表时 1234567891011CREATE TABLE 表名( 字段名 数据类型 PRIMARY KEY, 字段名 数据类型, 字段名 数据类型);CREATE TABLE 表名( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型， [constraint 约束名] primary key(字段名)); 建表后 1ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键 复合主键约束123456create table 表名称(字段名 数据类型,字段名 数据类型,字段名 数据类型,primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段); 删除主键约束1alter table 表名称 drop primary key; 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。 自增约束 AUTO_INCREMENT 一个表最多只能有一个自增长列; 当需要产生唯一标识符或顺序值时，可设置自增长; 自增长列约束的列必须是键列（主键列，唯一键列）; 自增约束的列的数据类型必须是整数类型; 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。 建表时 123456789101112create table 表名称(字段名 数据类型 primary key auto_increment,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,);create table 表名称(字段名 数据类型 default 默认值 ,字段名 数据类型 unique key auto_increment,字段名 数据类型 not null default 默认值,,primary key(字段名)); 建表后 1alter table 表名称 modify 字段名 数据类型 auto_increment; 删除自增约束12#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 MySQL 8.0新特性—自增变量的持久化在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如下： 创建的数据表中包含自增主键的id字段，语句如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#针对一个自增列，插入四个值。INSERT INTO test1VALUES(0),(0),(0),(0);#查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec)#删除id为4的记录DELETE FROM test1 WHERE id = 4;#再插入一个空值INSERT INTO test1 VALUES(0);#查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec)#删除id为5的数据DELETE FROM test1 where id=5;#重启数据库，重新插入一个空值INSERT INTO test1 values(0);#再次查询结果mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器来决定的，而该计数器只在内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。 在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 6 |+----+4 rows in set (0.00 sec) 从结果可以看出，自增变量已经持久化了。MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。 外键约束 FOREIGN KEY 限定某个表的某个字段的引用完整性； 比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分 主从表关系 主表（父表）：被引用的表，被参考的表 从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。 外键特征 从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列； 因为被依赖&#x2F;被参考的值必须是唯一的 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1;），也可以指定外键约束名； 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表； 删表时，先删从表（或先删除外键约束），再删除主表； 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据； 在“从表”中指定外键约束，并且一个表可以建立多个外键约束； 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t createtable’database.tablename’(errno: 150)”； 删除外键约束后，必须 手动 删除对应的索引； 双方约束- 添加了外键约束后，主表的修改和删除数据受约束； 添加了外键约束后，从表的添加和修改数据受约束； 在从表上建立外键，要求主表必须存在； 删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除； 添加外键约束建表时 12345678910111213create table 主表名称(字段1 数据类型 primary key,字段2 数据类型);create table 从表名称(字段1 数据类型 primary key,字段2 数据类型,[CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列 建表后 1ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx]; 删除外键约束123456#第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;#第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名; 默认约束 DEFAULT创建123456create table 表名称(字段名 数据类型 primary key,字段名 数据类型 unique key not null,字段名 数据类型 unique key,字段名 数据类型 not null default 默认值,); 123456alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 删除12alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空 视图 MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。 格式： 12345CREATE [OR REPLACE][ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION] 精简版： 12CREATE VIEW 视图名称AS 查询语句 Eg: 123456789#创建CREATE VIEW empvu80ASSELECT employee_id, last_name, salaryFROM employeesWHERE department_id = 80;#查询SELECT *FROM salvu80; 在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作； 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE； 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE； 视图定义基于一个 不可更新视图 ； 常量视图。 修改视图 CREATE VIEW 子句中各列的别名应和子查询中各列相对应。 123456CREATE OR REPLACE VIEW empvu80(id_number, name, sal, department_id)ASSELECT employee_id, first_name || &#x27; &#x27; || last_name, salary, department_idFROM employeesWHERE department_id = 80; 删除视图1DROP VIEW IF EXISTS 视图名称; 事务控制 指令 说明 set autocommit=0 开启事务 rollback 回滚 commit 事务提交 Q&amp;Aroot用户密码忘记该如何重置 通过任务管理或服务管理，关掉mysqld(服务进程)； 通过命令行+特殊参数开启mysqld； &lt;mysqld --defaults-file=&quot;D:\\ProgramFiles\\mysql\\MySQLServer5.7Data\\my.ini&quot; --skip-grant-tables 此时，mysqld服务进程已打开，并且不需要权限检查； mysql -uroot 无密码登录服务器，另启动一个客户端进行； 修改权限表： use mysql update user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39; and Host=&#39;localhost&#39;; flush privileges; 通过任务管理器，关掉mysqld服务进程； 再次通过服务管理，打开mysql服务； 即可用修改后的新代码登录。 ​","categories":[{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://erickinyae.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"hexo","slug":"hexo","date":"2023-11-04T15:41:40.000Z","updated":"2023-11-07T00:56:42.000Z","comments":true,"path":"2023/11/04/hexo/","permalink":"https://erickinyae.github.io/2023/11/04/hexo/","excerpt":"","text":"hexo基础指令 指令 作用 备注 发布与上线 hexo g -d 创建新文章 hexo new “title” 本地启动 hexo s","categories":[{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"git","slug":"git","date":"2023-10-21T15:57:30.000Z","updated":"2023-11-09T05:53:51.386Z","comments":true,"path":"2023/10/21/git/","permalink":"https://erickinyae.github.io/2023/10/21/git/","excerpt":"","text":"添加与提交代码的提交分为两个部分，分别是提交到缓存区，和提交到仓库。 提交到缓存区的方法为: 1git add &lt;filename&gt; 将代码从缓存区提交到仓库的方法为： 1git commit -m &lt;提交说明&gt; &lt;filename&gt; 1eg: git commit -m &quot;first commit&quot; ./agent.jar 当代码拉取到本地1git pull &lt;remote name&gt; &lt;branch&gt; 示例 1git pull git-demo master 克隆仓库代码到本地1git clone &lt;仓库链接&gt; 克隆操作会做以下三件事情： 拉取代码； 初始化本地仓库； 创建别名； 当前版本更改更改当前的版本代码，以实现代码版本回退的功能： 1git reset --hard &lt;代码版本号&gt; 代码版本号可以用git reflog 查到； 代码版本更改的底层原理是修改head指针指向的版本代码位置； git日志查看查看简单日志： 1git reflog 查看详细日志： 1git log git分支操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 一般情况下，每次写代码都需要将别人的代码先merge下来 12git merge hot-fix#将hot-fix分支上的代码merge到当前分支上进行合并； 代码冲突时当代码冲突时，需要人为的到代码中去选择要删除和保留哪些内容，然后！ 第一步，手动的将修改完成的代码加入到缓存区（git add &lt;filename&gt;)； 第二步，执行提交，此时使用git commit -m &lt;描述信息&gt; 时，不能带文件名。 不同分支时代码提交(pull request) 让master主分支将我拉到该项目的团队中，然后fork一份代码库给到我的分支中； 自己首先需要将代码clone下来，然后进行开发、修改等操作； 开发、修改完成后，需要将代码push到属于我的分支的代码库中； pull request：需要给其他分支发起推送请求，并等待其审核，如果代码没问题则合并到目标分支的代码中； git本地给远程库创建一个别名 代码 含义 git remote -v 查看当前远程库-别名列表； git remote add &lt;别名&gt; &lt;远程地址&gt; 给远程库取一个名字 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;","categories":[{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"CI\\CD","slug":"CI-CD","permalink":"https://erickinyae.github.io/tags/CI-CD/"}]}],"categories":[{"name":"安全","slug":"安全","permalink":"https://erickinyae.github.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"后端","slug":"后端","permalink":"https://erickinyae.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"其他","slug":"其他","permalink":"https://erickinyae.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://erickinyae.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"审计","slug":"审计","permalink":"https://erickinyae.github.io/tags/%E5%AE%A1%E8%AE%A1/"},{"name":"数据库","slug":"数据库","permalink":"https://erickinyae.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"CI\\CD","slug":"CI-CD","permalink":"https://erickinyae.github.io/tags/CI-CD/"}]}